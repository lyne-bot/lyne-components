/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { InterfaceAccordionItemAttributes } from "./components/sbb-accordion-item/sbb-accordion-item.custom";
import { InterfaceSbbActionGroupAttributes } from "./components/sbb-action-group/sbb-action-group.custom";
import { InterfaceAlertAttributes } from "./components/sbb-alert/sbb-alert.custom";
import { InterfaceTitleAttributes } from "./components/sbb-title/sbb-title.custom";
import { ButtonType, LinkTargetType } from "./global/interfaces/link-button-properties";
import { InterfaceSbbAlertGroupAttributes } from "./components/sbb-alert-group/sbb-alert-group.custom";
import { InterfaceButtonAttributes } from "./components/sbb-button/sbb-button.custom";
import { InterfaceSbbCardAttributes } from "./components/sbb-card/sbb-card.custom";
import { InterfaceCardBadgeAttributes } from "./components/sbb-card-badge/sbb-card-badge.custom";
import { InterfaceCardProductAttributes } from "./components/sbb-card-product/sbb-card-product.custom";
import { Time } from "./components/sbb-clock/sbb-clock.custom";
import { InterfaceSbbDividerAttributes } from "./components/sbb-divider/sbb-divider.custom.d";
import { InterfaceFooterAttributes } from "./components/sbb-footer/sbb-footer.custom";
import { InterfaceSbbFormFieldAttributes } from "./components/sbb-form-field/sbb-form-field.custom";
import { InterfaceGridAttributes } from "./components/sbb-grid/sbb-grid.custom";
import { InterfaceImageAttributes } from "./components/sbb-image/sbb-image.custom";
import { InterfaceJourneyHeaderAttributes } from "./components/sbb-journey-header/sbb-journey-header.custom";
import { InterfaceLinkAttributes } from "./components/sbb-link/sbb-link.custom";
import { InterfaceLinkButtonAttributes } from "./components/sbb-link-button/sbb-link-button.custom";
import { InterfaceTitleAttributes as InterfaceTitleAttributes1 } from "./components/sbb-title/sbb-title.custom.d";
import { InterfaceLinkListAttributes } from "./components/sbb-link-list/sbb-link-list.custom";
import { InterfaceLogoAttributes } from "./components/sbb-logo/sbb-logo.custom";
import { InterfaceOverlayEventDetail } from "./global/core/components/overlay/overlays-interface";
import { InterfacePearlChainAttributes } from "./components/sbb-pearl-chain/sbb-pearl-chain.custom";
import { InterfaceSectionAttributes } from "./components/sbb-section/sbb-section.custom";
import { InterfaceSignetAttributes } from "./components/sbb-signet/sbb-signet.custom";
import { InterfaceStackAttributes } from "./components/sbb-stack/sbb-stack.custom";
import { InterfaceTabTitleAttributes } from "./components/sbb-tab-title/sbb-tab-title.custom";
import { InterfaceTeaserAttributes } from "./components/sbb-teaser/sbb-teaser.custom";
import { InterfaceTimetableButtonAttributes } from "./components/sbb-timetable-button/sbb-timetable-button.custom";
import { InterfaceTimetableCusHimAttributes } from "./components/sbb-timetable-cus-him/sbb-timetable-cus-him.custom";
import { InterfaceTimetableParkAndRailAttributes } from "./components/sbb-timetable-park-and-rail/sbb-timetable-park-and-rail.custom";
import { InterfaceTimetablePlatformAttributes } from "./components/sbb-timetable-platform/sbb-timetable-platform.custom";
import { InterfaceTimetableTransportationNumberAttributes } from "./components/sbb-timetable-transportation-number/sbb-timetable-transportation-number.custom";
import { InterfaceTimetableTransportationTimeAttributes } from "./components/sbb-timetable-transportation-time/sbb-timetable-transportation-time.custom";
import { InterfaceTimetableTransportationWalkAttributes } from "./components/sbb-timetable-transportation-walk/sbb-timetable-transportation-walk.custom";
import { InterfaceTimetableTravelHintsAttributes } from "./components/sbb-timetable-travel-hints/sbb-timetable-travel-hints.custom";
import { InterfaceToggleCheckAttributes } from "./components/sbb-toggle-check/sbb-toggle-check.custom";
export namespace Components {
    interface SbbAccordion {
        /**
          * Use the aria-labelledby to reference to an id of a title outside of the accordion. That way we can improve the context for the screenreader users. When the first button in the accordion receives focus, the referenced title is also spoken out by the screenreader.
         */
        "ariaLabelledby"?: string;
        /**
          * Set this if you want to use the accordion on a non-white background.
         */
        "nonWhiteBackground"?: boolean;
        /**
          * Set this if you want the accordion to always have open only one item.
         */
        "onlyOneOpen"?: boolean;
    }
    interface SbbAccordionItem {
        /**
          * If set, an accordion can not be toggled
         */
        "disabled"?: boolean;
        /**
          * Id which is sent in the event after opening/closing accordion
         */
        "eventId"?: string;
        /**
          * Text to show as title for the accordion.
         */
        "heading": string;
        /**
          * Heading level.
         */
        "headingLevel"?: InterfaceAccordionItemAttributes['level'];
        /**
          * Set to true to open the accordion item. Set to false to close it.
         */
        "open"?: boolean;
    }
    interface SbbActionGroup {
        "align": InterfaceSbbActionGroupAttributes['align'];
        "horizontalFrom"?: InterfaceSbbActionGroupAttributes['horizontalFrom'];
        "orientation": InterfaceSbbActionGroupAttributes['orientation'];
    }
    interface SbbAlert {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby": string | undefined;
        /**
          * This will be forwarded as aria-label to the relevant nested element.
         */
        "accessibilityLabel": string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby": string | undefined;
        /**
          * The href value you want to link to.
         */
        "href": string | undefined;
        /**
          * Name of the icon which will be forward to the nested `sbb-icon`. Choose the icons from https://lyne.sbb.ch/tokens/icons/. Styling is optimized for icons of type HIM-CUS.
         */
        "iconName"?: string;
        /**
          * Whether the fade in animation should be disabled.
         */
        "inanimate": boolean;
        /**
          * With this way of handling the id we deviate from the recommended way that the host id is set with assignId(). This exception was made because the id must be used with the close button and therefore a reference must exist.
         */
        "internalId": string;
        /**
          * Content of the link
         */
        "linkContent"?: string;
        /**
          * Whether the alert is readonly. In readonly mode, there is no dismiss button offered to the user.
         */
        "readonly": boolean;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel": string | undefined;
        /**
          * Requests dismissal of the alert.
         */
        "requestDismissal": () => Promise<void>;
        /**
          * You can choose between `m` or `l` size.
         */
        "size": InterfaceAlertAttributes['size'];
        /**
          * Where to display the linked URL.
         */
        "target": LinkTargetType | string | undefined;
        /**
          * Content of title.
         */
        "titleContent"?: string;
        /**
          * Level of title, will be rendered as heading tag (e.g. h3). Defaults to level 3.
         */
        "titleLevel": InterfaceTitleAttributes['level'];
    }
    interface SbbAlertGroup {
        /**
          * Title for this alert group which is only visible for screen reader users.
         */
        "accessibilityTitle": string;
        /**
          * Level of the accessibility title, will be rendered as heading tag (e.g. h2). Defaults to level 2.
         */
        "accessibilityTitleLevel": InterfaceTitleAttributes['level'];
        /**
          * The role attribute defines how to announce alerts to the user.  'status': sets aria-live to polite and aria-atomic to true. 'alert': sets aria-live to assertive and aria-atomic to true.
         */
        "role": InterfaceSbbAlertGroupAttributes['role'];
    }
    interface SbbAutocomplete {
        /**
          * Autocomplete id. If you use multiple instances on a page, you should set individual id's to each of them.
         */
        "autocompleteId"?: string;
        /**
          * Id which is sent as the id in the eventDetail payload when a value is selected
         */
        "eventId"?: string;
        /**
          * Define if borderless variant of autocomplete input should be used. See documentation of sbb-text-input for details.
         */
        "inputBorderless"?: boolean;
        /**
          * Debounce timeout to use for the input. See documentation of sbb-text-input for details.
         */
        "inputDebounceTimeout"?: number;
        /**
          * Label attribute for the input element. See sbb-text-input for details.
         */
        "inputLabel": string;
        /**
          * Determine if the input label should be visible. See sbb-text-input for details.
         */
        "inputLabelVisible"?: boolean;
        /**
          * Name attribute for the input element. See sbb-text-input for details.
         */
        "inputName": string;
        /**
          * Placeholder attribute for the input element. See sbb-text-input for details.
         */
        "inputPlaceholder"?: string;
        /**
          * Items to show in the autocomplete interface. You should pass a stringified array of objects, containing the `text` key for each object with an appropriate value.
         */
        "items"?: string;
        /**
          * Define how many chars a user must type into the input field for the autocomplete list to show up.
         */
        "minChars"?: number;
        /**
          * The value to use as default value for the input. The input value or the selected autocomplete value is reflected to this attribute.
         */
        "value"?: string;
    }
    interface SbbAutocompleteItem {
        /**
          * The aria-posinset attribute for the list element
         */
        "ariaPosinset"?: number;
        /**
          * The aira-setsize attribute for the list element
         */
        "ariaSetsize"?: number;
        /**
          * The text to highlight within the string property
         */
        "highlight"?: string;
        /**
          * Mark the item as selected, which will change it's appearance and the according aria attributes.
         */
        "selected"?: boolean;
        /**
          * Text to show as content of the autocomplete item
         */
        "text": string;
    }
    interface SbbButton {
        /**
          * The aria-controls property identifies the element (or elements) whose contents or presence are controlled by the element on which this attribute is set. The value is forwarded to the native button element.
         */
        "ariaControls"?: InterfaceButtonAttributes['ariaControls'];
        /**
          * If you use the button to trigger another widget which itself is covering the page, you must provide an according attribute for aria-haspopup.
         */
        "ariaHaspopup"?: InterfaceButtonAttributes['popup'];
        /**
          * Set to true to get a disabled button
         */
        "disabled"?: boolean;
        /**
          * Id which is sent in the click event payload
         */
        "eventId"?: string;
        /**
          * Define if icon should be shown or not
         */
        "icon"?: boolean;
        /**
          * If you use an icon without a label, you must provide an iconDescription
         */
        "iconDescription"?: string;
        /**
          * Label text to show on the button
         */
        "label"?: string;
        /**
          * The name attribute to use for the button
         */
        "name"?: string;
        /**
          * Size variant, either l or m.
         */
        "size"?: InterfaceButtonAttributes['size'];
        /**
          * The type attribute to use for the button
         */
        "type"?: InterfaceButtonAttributes['type'];
        /**
          * The value attribute to use for the button
         */
        "value"?: string;
        /**
          * Variant of the button, like primary, secondary etc.
         */
        "variant"?: InterfaceButtonAttributes['variant'];
        /**
          * Set this property to true if you want only a visual represenation of a button, but no interaction (a div instead of a button will be rendered).
         */
        "visualButtonOnly"?: boolean;
    }
    interface SbbCard {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby": string | undefined;
        /**
          * This will be forwarded as aria-label to the relevant nested element.
         */
        "accessibilityLabel": string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby": string | undefined;
        /**
          * Used to set the component's active state.
         */
        "active": boolean;
        /**
          * Whether the browser will show the download dialog on click.
         */
        "download"?: boolean | undefined;
        /**
          * The <form> element to associate the button with.
         */
        "form"?: string | undefined;
        /**
          * The href value you want to link to.
         */
        "href": string | undefined;
        /**
          * Id used to identify the inner element.
         */
        "idValue"?: string;
        /**
          * The name of the button.
         */
        "name": string | undefined;
        /**
          * Option for set the component background color.
         */
        "negative": boolean;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string | undefined;
        /**
          * Size variant, either xs, s, m, l, xl or xxl.
         */
        "size"?: InterfaceSbbCardAttributes['size'];
        /**
          * Where to display the linked URL.
         */
        "target"?: LinkTargetType | string | undefined;
        /**
          * Default behaviour of the button.
         */
        "type": ButtonType | undefined;
        /**
          * The value associated with button `name` when it's submitted with the form data.
         */
        "value"?: string | undefined;
    }
    interface SbbCardBadge {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby": string | undefined;
        /**
          * Accessibility label text. This text gets exposed to screen reader users. The text should reflect all the information which gets passed into the component (as text or within the slot) so which is visible in the card badge, either through text or iconography.  Example text: Sales ticket price starts at CHF 37.50
         */
        "accessibilityLabel": string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby": string | undefined;
        /**
          * Badge appearance
         */
        "appearance": InterfaceCardBadgeAttributes['appearance'];
        /**
          * Mark as discount
         */
        "isDiscount"?: boolean;
        /**
          * Price text
         */
        "price"?: string;
        /**
          * Badge size
         */
        "size": InterfaceCardBadgeAttributes['size'];
        /**
          * From/above price text
         */
        "text"?: string;
    }
    interface SbbCardProduct {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby": string | undefined;
        /**
          * The text which gets exposed to screen reader users. The text should reflect all the information which gets passed into the component's slots and which is visible in the card, either through text or iconography.  Example text: Connection from X to Y, via Z, on date X. Ticket price starts at X.
         */
        "accessibilityLabel": string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby": string | undefined;
        /**
          * CardProduct appearance
         */
        "appearance"?: InterfaceCardProductAttributes['appearance'];
        /**
          * If you use the button to trigger another widget which itself is covering the page, you must provide an according attribute for aria-haspopup.
         */
        "ariaHaspopup"?: InterfaceCardProductAttributes['popup'];
        /**
          * Id which is sent in the click event payload
         */
        "eventId"?: string;
        /**
          * The href value you want to link to
         */
        "hrefValue"?: string;
        /**
          * The ID value you want to reference
         */
        "idValue"?: string;
        /**
          * Defines if the card behaves like a HTML button. Needs to be set true if the card does not point to a URL.
         */
        "isButton"?: boolean;
        /**
          * Set to true to get a disabled button
         */
        "isDisabled"?: boolean;
        /**
          * CardProduct layout
         */
        "layout"?: InterfaceCardProductAttributes['layout'];
        /**
          * The name attribute to use for the button
         */
        "name"?: string;
        /**
          * The type attribute to use for the button
         */
        "type"?: InterfaceCardProductAttributes['type'];
        /**
          * The value attribute to use for the button
         */
        "value"?: string;
    }
    interface SbbClock {
        /**
          * initialTime accepts a string following a ${number}:${number}:${number} pattern. If left empty or the string 'now' is used we will set the current time the client has on its device.
         */
        "initialTime"?: Time;
        /**
          * If set to true, the clock will be paused.
         */
        "paused"?: boolean;
    }
    interface SbbDivider {
        /**
          * Appearance property for displaying the component in dark mode
         */
        "negative"?: boolean;
        /**
          * Orientation property with possible values 'horizontal' | 'vertical'. Defaults to horizontal.
         */
        "orientation"?: InterfaceSbbDividerAttributes['orientation'];
    }
    interface SbbFooter {
        /**
          * Footer title text, visually hidden,  necessary for screenreaders
         */
        "accessibilityTitle": string;
        /**
          * Footer appearance
         */
        "appearance"?: InterfaceFooterAttributes['appearance'];
    }
    interface SbbFormError {
    }
    interface SbbFormField {
        /**
          * Whether to display the form field without a border.
         */
        "borderless": boolean;
        /**
          * Whether to reserve space for an error message. `none` does not reserve any space. `reserve` does reserve one row for an error message.
         */
        "errorSpace"?: InterfaceSbbFormFieldAttributes['errorSpace'];
        /**
          * Label text for the input which is internally rendered as `<label>`.
         */
        "label": string;
        /**
          * Indicates whether the input is optional.
         */
        "optional"?: boolean;
        /**
          * Size variant, either l or m.
         */
        "size"?: InterfaceSbbFormFieldAttributes['size'];
    }
    interface SbbGrid {
        /**
          * Section appearance
         */
        "appearance"?: InterfaceGridAttributes['appearance'];
        /**
          * Grid variant
         */
        "variant"?: InterfaceGridAttributes['variant'];
    }
    interface SbbIcon {
        /**
          * The aria-hidden property is set to "true" by default, since an icon alone does not convey any useful information for a screen-reader user.
         */
        "ariaHidden": string;
        /**
          * Only set the aria-label if aria-hidden is set to "false".
         */
        "ariaLabel": string;
        /**
          * The provided name consisting of the namespace and the name of the icon. If the namespace is missing, the default namespace "sbb" will be used. E.g. `name` (will use "sbb" as namespace) or `namespace:name`.
         */
        "name": string;
        /**
          * When set to `false`, SVG content that is HTTP fetched will not be checked if the response SVG content has any `<script>` elements, or any attributes that start with `on`, such as `onclick`.
          * @default true
         */
        "sanitize": boolean;
    }
    interface SbbImage {
        /**
          * An alt text is not always necessary (e.g. in teaser cards when additional link text is provided). In this case we can leave the value of the alt attribute blank, but the attribute itself still needs to be present. That way we can signal assistive technology, that they can skip the image.
         */
        "alt"?: string;
        /**
          * Set an aspect ratio default is '16-9' (16/9) other values: 'free', '1-1', '1-2', '2-1', '2-3', '3-2', '3-4', '4-3', '4-5', '5-4', '9-16'
         */
        "aspectRatio": InterfaceImageAttributes['aspectRatio'];
        /**
          * border-radius: if set to false, there will be no border-radius on the image
         */
        "borderRadius": boolean;
        /**
          * A caption can provide additional context to the image (e.g. descriptions and the like). Links will automatically receive tabindex=-1 if hideFromScreenreader is set to true. That way they will no longer become focusable.
         */
        "caption"?: string;
        /**
          * If a copyright text is provided, we will add it to the caption and create a structured data json-ld block with the copyright information.
         */
        "copyright"?: string;
        /**
          * Copyright holder can either be an Organization or a Person
         */
        "copyrightHolder": InterfaceImageAttributes['copyrightHolder'];
        /**
          * Set this to true, if you want to pass a custom focal point for the image. See full documentation here: https://docs.imgix.com/apis/rendering/focalpoint-crop
         */
        "customFocalPoint": boolean;
        /**
          * If the lazy property is set to true, the module will automatically change the decoding to async, otherwise the decoding is set to auto which leaves the handling up to the browser. Read more about the decoding attribute here: https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decoding
         */
        "decoding": InterfaceImageAttributes['decoding'];
        /**
          * Set this to true, to receive visual guidance where the custom focal point is currently set.
         */
        "focalPointDebug": boolean;
        /**
          * Pass in a floating number between 0 (left) and 1 (right).
         */
        "focalPointX": number;
        /**
          * Pass in a floating number between 0 (top) and 1 (bottom).
         */
        "focalPointY": number;
        /**
          * Right now the module is heavily coupled with the image delivery service imgix and depends on the original files being stored inside of AEM. You can pass in any https://cdn.img.sbb.ch img src address you find on sbb.ch to play around with it. Just strip the url parameters and paste in the plain file address. If you want to know how to best work with this module with images coming from a different source, please contact the LYNE Core Team.
         */
        "imageSrc"?: string;
        /**
          * The importance attribute is fairly new attribute which should help the browser decide which resources it should prioritise during page load. We will set the attribute value based on the value, we receive in the loading attribute. 'eager', which we use for the largest image within the initial viewport, will set the attribute value to 'high'. 'lazy', which we use for images below the fold, will set the attribute value to 'low'.
         */
        "importance": InterfaceImageAttributes['importance'];
        /**
          * With the support of native image lazy loading, we can now decide whether we want to load the image immediately or only once it is close to the visible viewport. The value eager is best used for images within the initial viewport. We want to load these images as fast as possible to improve the Core Web Vitals values. lazy on the other hand works best for images which are further down the page or invisible during the loading of the initial viewport.
         */
        "loading": InterfaceImageAttributes['loading'];
        /**
          * If set to true, we show a blurred version of the image as placeholder before the actual image shows up. This will help to improve the perceived loading performance. Read more about the idea of lqip here: https://medium.com/@imgix/lqip-your-images-for-fast-loading-2523d9ee4a62
         */
        "lqip": boolean;
        /**
          * With performance.mark you can log a timestamp associated with the name you define in performanceMark when a certain event is happening. In our case we will log the performance.mark into the PerformanceEntry API once the image is fully loaded. Performance monitoring tools like SpeedCurve or Lighthouse are then able to grab these entries from the PerformanceEntry API and give us additional information and insights about our page loading behaviour. We are then also able to monitor these values over a long period to see if our performance increases or decreases over time. Best to use lowercase strings here, separate words with underscores or dashes.
         */
        "performanceMark"?: string;
        /**
          * With the pictureSizesConfig object, you can pass in information into image about what kind of source elements should get rendered. mediaQueries accepts multiple Media Query entries which can get combined by defining a conditionOperator. Type is: stringified InterfaceImageAttributesSizesConfig-Object An example could look like this: {    "breakpoints": [      {        "image": {          "height": "675",          "width": "1200"        },        "mediaQueries": [          {            "conditionFeature": "min-width",            "conditionFeatureValue": {              "lyneDesignToken": true,              "value": "breakpoint-large-min"            },            "conditionOperator": false          }        ]      },      {        "image": {          "height": "549",          "width": "976"        },        "mediaQueries": [          {            "conditionFeature": "min-width",            "conditionFeatureValue": {              "lyneDesignToken": true,              "value": "breakpoint-small-min"            },            "conditionOperator": false          }        ]      },      {        "image": {          "height": "180",          "width": "320"        },        "mediaQueries": [          {            "conditionFeature": "max-width",            "conditionFeatureValue": {              "lyneDesignToken": true,              "value": "breakpoint-micro-max"            },            "conditionOperator": "and"          },          {            "conditionFeature": "orientation",            "conditionFeatureValue": {              "lyneDesignToken": false,              "value": "landscape"            },            "conditionOperator": false          }        ]      }    ]  }
         */
        "pictureSizesConfig"?: string;
    }
    interface SbbJourneyHeader {
        /**
          * Journey header appearance
         */
        "appearance"?: InterfaceJourneyHeaderAttributes['appearance'];
        /**
          * Destination location for the journey header
         */
        "destination": string;
        /**
          * Is the journey a round trip. If so it gets indicated through a roundtrip icon
         */
        "isRoundTrip"?: boolean;
        /**
          * A11y Tip: Sometimes we need to set an id, especially if we want to associate a relationship with another element through the use of aria-labelledby or aria-describedby or just offer an anchor target
         */
        "journeyHeaderId"?: '';
        /**
          * Journey header markup: Depends on the context where the journey will be used but it is important to pick the correct markup element to match to correct semantics
         */
        "markup"?: InterfaceJourneyHeaderAttributes['markup'];
        /**
          * Origin location for the journey header
         */
        "origin": string;
        /**
          * Journey header size
         */
        "size"?: InterfaceJourneyHeaderAttributes['size'];
    }
    interface SbbLink {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby": string | undefined;
        /**
          * This will be forwarded as aria-label to the relevant nested element.
         */
        "accessibilityLabel": string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby": string | undefined;
        /**
          * Disabled attribute if link is used as button (optional)
         */
        "disabled"?: boolean;
        /**
          * If set to true, the browser will show the download dialog on click (optional).
         */
        "download"?: boolean;
        /**
          * Id which is sent in the click event payload
         */
        "eventId"?: string;
        /**
          * Form attribute if link is used as button (optional)
         */
        "form"?: string;
        /**
          * The href value you want to link to (optional, if its not present link becomes a button)
         */
        "href": string | undefined;
        /**
          * The icon name we want to use, choose from the small icon variants from the ui-icons category from here https://lyne.sbb.ch/tokens/icons/ (optional). Inline variant doesn't support icons.
         */
        "iconName"?: string;
        /**
          * Moves the icon to the end of the component if set to true (optional).
         */
        "iconPlacement"?: InterfaceLinkAttributes['iconPlacement'];
        /**
          * Pass in an id, if you need to identify the link element (optional).
         */
        "idValue"?: string;
        /**
          * Name attribute if link is used as button (optional)
         */
        "name": string | undefined;
        /**
          * Negative coloring variant flag.
         */
        "negative": boolean;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string | undefined;
        /**
          * Where to display the linked URL.
         */
        "target"?: LinkTargetType | string | undefined;
        /**
          * Text size, the link should get in the non-button variation. With inline variant, the text size adapts to where it is used.
         */
        "textSize": InterfaceLinkAttributes['textSize'];
        /**
          * Type attribute if link is used as button (optional)
         */
        "type": InterfaceLinkAttributes['buttonType'] | undefined;
        /**
          * The value associated with button `name` when it's submitted with the form data.
         */
        "value"?: string;
        /**
          * Applies link inline styles (underline, inherit coloring/font-size etc).
         */
        "variant": InterfaceLinkAttributes['variant'];
    }
    interface SbbLinkButton {
        /**
          * If set to true, the browser will show the download dialog on click.
         */
        "download"?: boolean;
        /**
          * The href value you want to link to
         */
        "hrefValue": string;
        /**
          * The icon name we want to use, choose from the small icon variants from the ui-icons category from here https://lyne.sbb.ch/tokens/icons/
         */
        "icon"?: string;
        /**
          * Decide whether the icon should get flipped horizontally if the document writing mode is changed from ltr to rtl or vice versa.
         */
        "iconFlip"?: boolean;
        /**
          * The icon can either be place before or after the text
         */
        "iconPlacement": InterfaceLinkButtonAttributes['iconPlacement'];
        /**
          * Pass in an id, if you need to identify the link element.
         */
        "idValue"?: string;
        /**
          * The link text we want to visually show
         */
        "text": string;
        /**
          * Choose the link button style variant
         */
        "variant": InterfaceLinkButtonAttributes['variant'];
    }
    interface SbbLinkList {
        /**
          * Selected breakpoint from which the list is rendered horizontally.
         */
        "horizontalFrom"?: InterfaceLinkListAttributes['horizontalFromBreakpoint'];
        /**
          * Negative coloring variant flag.
         */
        "negative": boolean;
        /**
          * The orientation in which the list will be shown vertical or horizontal.
         */
        "orientation": InterfaceLinkListAttributes['orientation'];
        /**
          * The title text we want to show before the list.
         */
        "titleContent"?: string;
        /**
          * This id will be forwarded to the relevant inner element.
         */
        "titleId": string;
        /**
          * The semantic level of the title, e.g. 2 = h2.
         */
        "titleLevel"?: InterfaceTitleAttributes1['level'];
    }
    interface SbbLogo {
        /**
          * The Logo needs to have a certain protective room around it
         */
        "protectiveRoom"?: InterfaceLogoAttributes['protectiveRoom'];
        /**
          * According to the Corporate Design Guidelines the logo can be used in these variants
         */
        "variant"?: InterfaceLogoAttributes['variant'];
    }
    interface SbbOverlay {
        /**
          * Dismiss the overlay.
         */
        "dismiss": (data?: any, role?: string) => Promise<boolean>;
        "overlayIndex": number;
        /**
          * Present the overlay.
         */
        "present": () => Promise<void>;
    }
    interface SbbPearlChain {
        /**
          * Per default, the current location has a pulsating animation. You can disable the animation with this property.
         */
        "disableAnimation"?: boolean;
        /**
          * Stringified JSON to define the legs of the pearl-chain. Format: `{"legs": [{"cancellation": true, "duration": 25}, ...]}` `duration`: number between 0 and 100. Duration of the leg is relative to the total travel time. Example: departure 16:30, change at 16:40, arrival at 17:00. So the change should have a duration of 33.33%. `cancellation`: if set, the leg will be marked as canceled.
         */
        "legs": string;
        /**
          * Define, if the pearl-chain represents a connection in the past, in the future or if it is a currently running connection. If it is currently running, provide a number between 0 and 100, which will represent the current location on the pearl-chain.
         */
        "status"?: InterfacePearlChainAttributes['status'];
    }
    interface SbbSection {
        /**
          * Section appearance
         */
        "appearance"?: InterfaceSectionAttributes['appearance'];
        /**
          * Section width
         */
        "width"?: InterfaceSectionAttributes['width'];
    }
    interface SbbSignet {
        /**
          * The Signet needs to have a certain protective room around it
         */
        "protectiveRoom"?: InterfaceSignetAttributes['protectiveRoom'];
        /**
          * According to the Corporate Design Guidelines the signet can be used in these variants
         */
        "variant"?: InterfaceSignetAttributes['variant'];
    }
    interface SbbSlotComponent {
    }
    interface SbbStack {
        /**
          * Stack appearance
         */
        "appearance"?: InterfaceStackAttributes['appearance'];
        /**
          * Collapse horizontal stack into vertical layout below a certain breakpoint. This has only an effect for horizontal appearances.
         */
        "collapseHorizontalBelow"?: InterfaceStackAttributes['collapseHorizontalBelow'];
        /**
          * Stack gap horizontal, defines the space between each stack items in the vertical direction. The spacing can be fixed or responsive (which then depends on the breakpoint). The `x` in the fixed spacing scale is a representation of the base spacing unit. E.g. `3 * base spacing unit`
         */
        "gapHorizontal"?: InterfaceStackAttributes['spacing'];
        /**
          * Stack gap vertical, defines the space between each stack items in the horizontal direction. The spacing can be fixed or responsive (which then depends on the breakpoint). The `x` in the fixed spacing scale is a representation of the base spacing unit. E.g. `3 * base spacing unit`
         */
        "gapVertical"?: InterfaceStackAttributes['spacing'];
        /**
          * Render stack as placeholder
         */
        "isPlaceholder"?: boolean;
        /**
          * Render horizontal stack as non-wrapping stack
         */
        "noWrap"?: boolean;
        /**
          * Space before the stack
         */
        "spaceLeading"?: InterfaceStackAttributes['spacing'];
        /**
          * Space before the stack
         */
        "spaceTrailing"?: InterfaceStackAttributes['spacing'];
        /**
          * Stack height, reflects CSS property `height` and accepts all appropriate/valid CSS height values
         */
        "stackHeight"?: string;
        /**
          * Stack width, reflects CSS property `width` and accepts all appropriate/valid CSS width values
         */
        "stackWidth"?: string;
        /**
          * Stack tag / HTML representation of the stack. If the stack represents a list of items change the HTML representation to `ul` or `ol` tag. In this case the only allowed stack items are `li` elements.
         */
        "tag"?: InterfaceStackAttributes['tag'];
    }
    interface SbbTabAmount {
    }
    interface SbbTabGroup {
        /**
          * Activates a tab by index.
          * @param tabIndex The index of the tab you want to activate.
         */
        "activateTab": (tabIndex: number) => Promise<void>;
        /**
          * Disables a tab by index.
          * @param tabIndex The index of the tab you want to disable.
         */
        "disableTab": (tabIndex: number) => Promise<void>;
        /**
          * Enables a tab by index.
          * @param tabIndex The index of the tab you want to enable.
         */
        "enableTab": (tabIndex: number) => Promise<void>;
        /**
          * Sets the initial tab. If it matches a disabled tab or exceeds the length of the tab group, the first enabled tab will be selected.
         */
        "initialSelectedIndex": number;
    }
    interface SbbTabTitle {
        /**
          * Active tab state
         */
        "active"?: boolean;
        /**
          * Disabled tab state
         */
        "disabled"?: boolean;
        /**
          * The level will correspond to the heading tag generated in the title. Use this property to generate the appropriate header tag, taking SEO into consideration.
         */
        "level"?: InterfaceTabTitleAttributes['level'];
    }
    interface SbbTeaser {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby": string | undefined;
        /**
          * The text which gets exposed to screen reader users. The text should reflect all the information  Example text: Connection from X to Y, via Z, on date X. Ticket price starts at X.
         */
        "accessibilityLabel": string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby": string | undefined;
        /**
          * The href value you want to link to
         */
        "href": string;
        /**
          * Teaser variant - when this is true the text-content will be under the image otherwise it will be displayed next to the image.
         */
        "isStacked": boolean;
        /**
          * Heading level of the sbb-title element (e.g. h1-h6)
         */
        "titleLevel": InterfaceTeaserAttributes['titleLevel'];
    }
    interface SbbTeaserHero {
        /**
          * This will be forwarded as aria-describedby to the anchor tag.
         */
        "accessibilityDescribedby": string | undefined;
        /**
          * This will be forwarded as aria-label to anchor tag.
         */
        "accessibilityLabel": string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the anchor tag.
         */
        "accessibilityLabelledby": string | undefined;
        /**
          * The href value you want to link to.
         */
        "href": string | undefined;
        /**
          * Pass in an id, if you need to identify the inner link element.
         */
        "idValue"?: string;
        /**
          * Image alt text will be passed to `sbb-image`.
         */
        "imageAlt"?: string;
        /**
          * Image src will be passed to `sbb-image`.
         */
        "imageSrc"?: string;
        /**
          * Panel link text.
         */
        "linkContent"?: string;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string | undefined;
        /**
          * Where to display the linked URL.
         */
        "target"?: LinkTargetType | string | undefined;
    }
    interface SbbTimetable {
    }
    interface SbbTimetableBarrierFree {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableButton {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableButtonAttributes['appearance'];
        /**
          * If you use the button to trigger another widget which itself is covering the page, you must provide an according attribute for aria-haspopup.
         */
        "ariaHaspopup"?: InterfaceTimetableButtonAttributes['popup'];
        /**
          * If appearance is set to 'cus-him' or 'walk', we need to provide a config to popultate the nested web component.
         */
        "config"?: string;
        /**
          * Set to true to get a disabled button
         */
        "disabled"?: boolean;
        /**
          * Id which is sent in the click event payload
         */
        "eventId"?: string;
        /**
          * Set to true to initially show the state, which would get set by pressing the button.
         */
        "expanded"?: boolean;
        /**
          * The name attribute to use for the button
         */
        "name"?: string;
    }
    interface SbbTimetableCusHim {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableCusHimAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableDuration {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableOccupancy {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableParkAndRail {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableParkAndRailAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetablePlatform {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetablePlatformAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableRow {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableRowButton {
        /**
          * Id which is sent in the event of clicking the button
         */
        "eventId"?: string;
        /**
          * Set to true to initially show the state, which would get set by pressing the button.
         */
        "expanded"?: boolean;
    }
    interface SbbTimetableRowColumnHeaders {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableRowDayChange {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableRowHeader {
        "config": string;
    }
    interface SbbTimetableTransportationDetails {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableTransportationNumber {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableTransportationNumberAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableTransportationTime {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableTransportationTimeAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableTransportationWalk {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableTransportationWalkAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableTravelHints {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableTravelHintsAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTitle {
        /**
          * Title level
         */
        "level"?: InterfaceTitleAttributes['level'];
        /**
          * Choose negative variant
         */
        "negative"?: boolean;
        /**
          * A11y Tip: Sometimes we need to set an id, especially if we want to associate a relationship with another element through the use of aria-labelledby or aria-describedby or just offer an anchor target
         */
        "titleId": string;
        /**
          * Visual level for the title. Optional, if not set, the value of level will be used.
         */
        "visualLevel"?: InterfaceTitleAttributes['visualLevel'];
        /**
          * Sometimes we need a title in the markup to present a proper hierarchy to the screenreaders while we do not want to let that title appear visually. In this case we set visuallyHidden to true
         */
        "visuallyHidden"?: false;
    }
    interface SbbToggleCheck {
        /**
          * The aria-describedby prop for the hidden input.
         */
        "accessibilityDescribedby": string | undefined;
        /**
          * The aria-label prop for the hidden input.
         */
        "accessibilityLabel": string | undefined;
        /**
          * The aria-labelledby prop for the hidden input.
         */
        "accessibilityLabelledby": string | undefined;
        /**
          * Whether the toggle-check is checked.
         */
        "checked": boolean;
        /**
          * The disabled prop for the disabled state.
         */
        "disabled": boolean;
        /**
          * The svg name for the true state - default -> 'tick-small'
         */
        "icon": string;
        /**
          * Id of the internal input element - default id will be set automatically.
         */
        "inputId": string;
        /**
          * The label position relative to the toggle. Defaults to 'after'
         */
        "labelPosition"?: InterfaceToggleCheckAttributes['labelPosition'];
        /**
          * Name of the toggle-check.
         */
        "name"?: string;
        /**
          * The required prop for the required state.
         */
        "required"?: boolean;
        /**
          * Value of toggle-check.
         */
        "value"?: string;
    }
}
export interface SbbAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSbbAlertElement;
}
export interface SbbAlertGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSbbAlertGroupElement;
}
export interface SbbButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSbbButtonElement;
}
export interface SbbCardCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSbbCardElement;
}
export interface SbbLinkCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSbbLinkElement;
}
export interface SbbOverlayCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSbbOverlayElement;
}
export interface SbbTabGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSbbTabGroupElement;
}
export interface SbbToggleCheckCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSbbToggleCheckElement;
}
declare global {
    interface HTMLSbbAccordionElement extends Components.SbbAccordion, HTMLStencilElement {
    }
    var HTMLSbbAccordionElement: {
        prototype: HTMLSbbAccordionElement;
        new (): HTMLSbbAccordionElement;
    };
    interface HTMLSbbAccordionItemElement extends Components.SbbAccordionItem, HTMLStencilElement {
    }
    var HTMLSbbAccordionItemElement: {
        prototype: HTMLSbbAccordionItemElement;
        new (): HTMLSbbAccordionItemElement;
    };
    interface HTMLSbbActionGroupElement extends Components.SbbActionGroup, HTMLStencilElement {
    }
    var HTMLSbbActionGroupElement: {
        prototype: HTMLSbbActionGroupElement;
        new (): HTMLSbbActionGroupElement;
    };
    interface HTMLSbbAlertElement extends Components.SbbAlert, HTMLStencilElement {
    }
    var HTMLSbbAlertElement: {
        prototype: HTMLSbbAlertElement;
        new (): HTMLSbbAlertElement;
    };
    interface HTMLSbbAlertGroupElement extends Components.SbbAlertGroup, HTMLStencilElement {
    }
    var HTMLSbbAlertGroupElement: {
        prototype: HTMLSbbAlertGroupElement;
        new (): HTMLSbbAlertGroupElement;
    };
    interface HTMLSbbAutocompleteElement extends Components.SbbAutocomplete, HTMLStencilElement {
    }
    var HTMLSbbAutocompleteElement: {
        prototype: HTMLSbbAutocompleteElement;
        new (): HTMLSbbAutocompleteElement;
    };
    interface HTMLSbbAutocompleteItemElement extends Components.SbbAutocompleteItem, HTMLStencilElement {
    }
    var HTMLSbbAutocompleteItemElement: {
        prototype: HTMLSbbAutocompleteItemElement;
        new (): HTMLSbbAutocompleteItemElement;
    };
    interface HTMLSbbButtonElement extends Components.SbbButton, HTMLStencilElement {
    }
    var HTMLSbbButtonElement: {
        prototype: HTMLSbbButtonElement;
        new (): HTMLSbbButtonElement;
    };
    interface HTMLSbbCardElement extends Components.SbbCard, HTMLStencilElement {
    }
    var HTMLSbbCardElement: {
        prototype: HTMLSbbCardElement;
        new (): HTMLSbbCardElement;
    };
    interface HTMLSbbCardBadgeElement extends Components.SbbCardBadge, HTMLStencilElement {
    }
    var HTMLSbbCardBadgeElement: {
        prototype: HTMLSbbCardBadgeElement;
        new (): HTMLSbbCardBadgeElement;
    };
    interface HTMLSbbCardProductElement extends Components.SbbCardProduct, HTMLStencilElement {
    }
    var HTMLSbbCardProductElement: {
        prototype: HTMLSbbCardProductElement;
        new (): HTMLSbbCardProductElement;
    };
    interface HTMLSbbClockElement extends Components.SbbClock, HTMLStencilElement {
    }
    var HTMLSbbClockElement: {
        prototype: HTMLSbbClockElement;
        new (): HTMLSbbClockElement;
    };
    interface HTMLSbbDividerElement extends Components.SbbDivider, HTMLStencilElement {
    }
    var HTMLSbbDividerElement: {
        prototype: HTMLSbbDividerElement;
        new (): HTMLSbbDividerElement;
    };
    interface HTMLSbbFooterElement extends Components.SbbFooter, HTMLStencilElement {
    }
    var HTMLSbbFooterElement: {
        prototype: HTMLSbbFooterElement;
        new (): HTMLSbbFooterElement;
    };
    interface HTMLSbbFormErrorElement extends Components.SbbFormError, HTMLStencilElement {
    }
    var HTMLSbbFormErrorElement: {
        prototype: HTMLSbbFormErrorElement;
        new (): HTMLSbbFormErrorElement;
    };
    interface HTMLSbbFormFieldElement extends Components.SbbFormField, HTMLStencilElement {
    }
    var HTMLSbbFormFieldElement: {
        prototype: HTMLSbbFormFieldElement;
        new (): HTMLSbbFormFieldElement;
    };
    interface HTMLSbbGridElement extends Components.SbbGrid, HTMLStencilElement {
    }
    var HTMLSbbGridElement: {
        prototype: HTMLSbbGridElement;
        new (): HTMLSbbGridElement;
    };
    interface HTMLSbbIconElement extends Components.SbbIcon, HTMLStencilElement {
    }
    var HTMLSbbIconElement: {
        prototype: HTMLSbbIconElement;
        new (): HTMLSbbIconElement;
    };
    interface HTMLSbbImageElement extends Components.SbbImage, HTMLStencilElement {
    }
    var HTMLSbbImageElement: {
        prototype: HTMLSbbImageElement;
        new (): HTMLSbbImageElement;
    };
    interface HTMLSbbJourneyHeaderElement extends Components.SbbJourneyHeader, HTMLStencilElement {
    }
    var HTMLSbbJourneyHeaderElement: {
        prototype: HTMLSbbJourneyHeaderElement;
        new (): HTMLSbbJourneyHeaderElement;
    };
    interface HTMLSbbLinkElement extends Components.SbbLink, HTMLStencilElement {
    }
    var HTMLSbbLinkElement: {
        prototype: HTMLSbbLinkElement;
        new (): HTMLSbbLinkElement;
    };
    interface HTMLSbbLinkButtonElement extends Components.SbbLinkButton, HTMLStencilElement {
    }
    var HTMLSbbLinkButtonElement: {
        prototype: HTMLSbbLinkButtonElement;
        new (): HTMLSbbLinkButtonElement;
    };
    interface HTMLSbbLinkListElement extends Components.SbbLinkList, HTMLStencilElement {
    }
    var HTMLSbbLinkListElement: {
        prototype: HTMLSbbLinkListElement;
        new (): HTMLSbbLinkListElement;
    };
    interface HTMLSbbLogoElement extends Components.SbbLogo, HTMLStencilElement {
    }
    var HTMLSbbLogoElement: {
        prototype: HTMLSbbLogoElement;
        new (): HTMLSbbLogoElement;
    };
    interface HTMLSbbOverlayElement extends Components.SbbOverlay, HTMLStencilElement {
    }
    var HTMLSbbOverlayElement: {
        prototype: HTMLSbbOverlayElement;
        new (): HTMLSbbOverlayElement;
    };
    interface HTMLSbbPearlChainElement extends Components.SbbPearlChain, HTMLStencilElement {
    }
    var HTMLSbbPearlChainElement: {
        prototype: HTMLSbbPearlChainElement;
        new (): HTMLSbbPearlChainElement;
    };
    interface HTMLSbbSectionElement extends Components.SbbSection, HTMLStencilElement {
    }
    var HTMLSbbSectionElement: {
        prototype: HTMLSbbSectionElement;
        new (): HTMLSbbSectionElement;
    };
    interface HTMLSbbSignetElement extends Components.SbbSignet, HTMLStencilElement {
    }
    var HTMLSbbSignetElement: {
        prototype: HTMLSbbSignetElement;
        new (): HTMLSbbSignetElement;
    };
    interface HTMLSbbSlotComponentElement extends Components.SbbSlotComponent, HTMLStencilElement {
    }
    var HTMLSbbSlotComponentElement: {
        prototype: HTMLSbbSlotComponentElement;
        new (): HTMLSbbSlotComponentElement;
    };
    interface HTMLSbbStackElement extends Components.SbbStack, HTMLStencilElement {
    }
    var HTMLSbbStackElement: {
        prototype: HTMLSbbStackElement;
        new (): HTMLSbbStackElement;
    };
    interface HTMLSbbTabAmountElement extends Components.SbbTabAmount, HTMLStencilElement {
    }
    var HTMLSbbTabAmountElement: {
        prototype: HTMLSbbTabAmountElement;
        new (): HTMLSbbTabAmountElement;
    };
    interface HTMLSbbTabGroupElement extends Components.SbbTabGroup, HTMLStencilElement {
    }
    var HTMLSbbTabGroupElement: {
        prototype: HTMLSbbTabGroupElement;
        new (): HTMLSbbTabGroupElement;
    };
    interface HTMLSbbTabTitleElement extends Components.SbbTabTitle, HTMLStencilElement {
    }
    var HTMLSbbTabTitleElement: {
        prototype: HTMLSbbTabTitleElement;
        new (): HTMLSbbTabTitleElement;
    };
    interface HTMLSbbTeaserElement extends Components.SbbTeaser, HTMLStencilElement {
    }
    var HTMLSbbTeaserElement: {
        prototype: HTMLSbbTeaserElement;
        new (): HTMLSbbTeaserElement;
    };
    interface HTMLSbbTeaserHeroElement extends Components.SbbTeaserHero, HTMLStencilElement {
    }
    var HTMLSbbTeaserHeroElement: {
        prototype: HTMLSbbTeaserHeroElement;
        new (): HTMLSbbTeaserHeroElement;
    };
    interface HTMLSbbTimetableElement extends Components.SbbTimetable, HTMLStencilElement {
    }
    var HTMLSbbTimetableElement: {
        prototype: HTMLSbbTimetableElement;
        new (): HTMLSbbTimetableElement;
    };
    interface HTMLSbbTimetableBarrierFreeElement extends Components.SbbTimetableBarrierFree, HTMLStencilElement {
    }
    var HTMLSbbTimetableBarrierFreeElement: {
        prototype: HTMLSbbTimetableBarrierFreeElement;
        new (): HTMLSbbTimetableBarrierFreeElement;
    };
    interface HTMLSbbTimetableButtonElement extends Components.SbbTimetableButton, HTMLStencilElement {
    }
    var HTMLSbbTimetableButtonElement: {
        prototype: HTMLSbbTimetableButtonElement;
        new (): HTMLSbbTimetableButtonElement;
    };
    interface HTMLSbbTimetableCusHimElement extends Components.SbbTimetableCusHim, HTMLStencilElement {
    }
    var HTMLSbbTimetableCusHimElement: {
        prototype: HTMLSbbTimetableCusHimElement;
        new (): HTMLSbbTimetableCusHimElement;
    };
    interface HTMLSbbTimetableDurationElement extends Components.SbbTimetableDuration, HTMLStencilElement {
    }
    var HTMLSbbTimetableDurationElement: {
        prototype: HTMLSbbTimetableDurationElement;
        new (): HTMLSbbTimetableDurationElement;
    };
    interface HTMLSbbTimetableOccupancyElement extends Components.SbbTimetableOccupancy, HTMLStencilElement {
    }
    var HTMLSbbTimetableOccupancyElement: {
        prototype: HTMLSbbTimetableOccupancyElement;
        new (): HTMLSbbTimetableOccupancyElement;
    };
    interface HTMLSbbTimetableParkAndRailElement extends Components.SbbTimetableParkAndRail, HTMLStencilElement {
    }
    var HTMLSbbTimetableParkAndRailElement: {
        prototype: HTMLSbbTimetableParkAndRailElement;
        new (): HTMLSbbTimetableParkAndRailElement;
    };
    interface HTMLSbbTimetablePlatformElement extends Components.SbbTimetablePlatform, HTMLStencilElement {
    }
    var HTMLSbbTimetablePlatformElement: {
        prototype: HTMLSbbTimetablePlatformElement;
        new (): HTMLSbbTimetablePlatformElement;
    };
    interface HTMLSbbTimetableRowElement extends Components.SbbTimetableRow, HTMLStencilElement {
    }
    var HTMLSbbTimetableRowElement: {
        prototype: HTMLSbbTimetableRowElement;
        new (): HTMLSbbTimetableRowElement;
    };
    interface HTMLSbbTimetableRowButtonElement extends Components.SbbTimetableRowButton, HTMLStencilElement {
    }
    var HTMLSbbTimetableRowButtonElement: {
        prototype: HTMLSbbTimetableRowButtonElement;
        new (): HTMLSbbTimetableRowButtonElement;
    };
    interface HTMLSbbTimetableRowColumnHeadersElement extends Components.SbbTimetableRowColumnHeaders, HTMLStencilElement {
    }
    var HTMLSbbTimetableRowColumnHeadersElement: {
        prototype: HTMLSbbTimetableRowColumnHeadersElement;
        new (): HTMLSbbTimetableRowColumnHeadersElement;
    };
    interface HTMLSbbTimetableRowDayChangeElement extends Components.SbbTimetableRowDayChange, HTMLStencilElement {
    }
    var HTMLSbbTimetableRowDayChangeElement: {
        prototype: HTMLSbbTimetableRowDayChangeElement;
        new (): HTMLSbbTimetableRowDayChangeElement;
    };
    interface HTMLSbbTimetableRowHeaderElement extends Components.SbbTimetableRowHeader, HTMLStencilElement {
    }
    var HTMLSbbTimetableRowHeaderElement: {
        prototype: HTMLSbbTimetableRowHeaderElement;
        new (): HTMLSbbTimetableRowHeaderElement;
    };
    interface HTMLSbbTimetableTransportationDetailsElement extends Components.SbbTimetableTransportationDetails, HTMLStencilElement {
    }
    var HTMLSbbTimetableTransportationDetailsElement: {
        prototype: HTMLSbbTimetableTransportationDetailsElement;
        new (): HTMLSbbTimetableTransportationDetailsElement;
    };
    interface HTMLSbbTimetableTransportationNumberElement extends Components.SbbTimetableTransportationNumber, HTMLStencilElement {
    }
    var HTMLSbbTimetableTransportationNumberElement: {
        prototype: HTMLSbbTimetableTransportationNumberElement;
        new (): HTMLSbbTimetableTransportationNumberElement;
    };
    interface HTMLSbbTimetableTransportationTimeElement extends Components.SbbTimetableTransportationTime, HTMLStencilElement {
    }
    var HTMLSbbTimetableTransportationTimeElement: {
        prototype: HTMLSbbTimetableTransportationTimeElement;
        new (): HTMLSbbTimetableTransportationTimeElement;
    };
    interface HTMLSbbTimetableTransportationWalkElement extends Components.SbbTimetableTransportationWalk, HTMLStencilElement {
    }
    var HTMLSbbTimetableTransportationWalkElement: {
        prototype: HTMLSbbTimetableTransportationWalkElement;
        new (): HTMLSbbTimetableTransportationWalkElement;
    };
    interface HTMLSbbTimetableTravelHintsElement extends Components.SbbTimetableTravelHints, HTMLStencilElement {
    }
    var HTMLSbbTimetableTravelHintsElement: {
        prototype: HTMLSbbTimetableTravelHintsElement;
        new (): HTMLSbbTimetableTravelHintsElement;
    };
    interface HTMLSbbTitleElement extends Components.SbbTitle, HTMLStencilElement {
    }
    var HTMLSbbTitleElement: {
        prototype: HTMLSbbTitleElement;
        new (): HTMLSbbTitleElement;
    };
    interface HTMLSbbToggleCheckElement extends Components.SbbToggleCheck, HTMLStencilElement {
    }
    var HTMLSbbToggleCheckElement: {
        prototype: HTMLSbbToggleCheckElement;
        new (): HTMLSbbToggleCheckElement;
    };
    interface HTMLElementTagNameMap {
        "sbb-accordion": HTMLSbbAccordionElement;
        "sbb-accordion-item": HTMLSbbAccordionItemElement;
        "sbb-action-group": HTMLSbbActionGroupElement;
        "sbb-alert": HTMLSbbAlertElement;
        "sbb-alert-group": HTMLSbbAlertGroupElement;
        "sbb-autocomplete": HTMLSbbAutocompleteElement;
        "sbb-autocomplete-item": HTMLSbbAutocompleteItemElement;
        "sbb-button": HTMLSbbButtonElement;
        "sbb-card": HTMLSbbCardElement;
        "sbb-card-badge": HTMLSbbCardBadgeElement;
        "sbb-card-product": HTMLSbbCardProductElement;
        "sbb-clock": HTMLSbbClockElement;
        "sbb-divider": HTMLSbbDividerElement;
        "sbb-footer": HTMLSbbFooterElement;
        "sbb-form-error": HTMLSbbFormErrorElement;
        "sbb-form-field": HTMLSbbFormFieldElement;
        "sbb-grid": HTMLSbbGridElement;
        "sbb-icon": HTMLSbbIconElement;
        "sbb-image": HTMLSbbImageElement;
        "sbb-journey-header": HTMLSbbJourneyHeaderElement;
        "sbb-link": HTMLSbbLinkElement;
        "sbb-link-button": HTMLSbbLinkButtonElement;
        "sbb-link-list": HTMLSbbLinkListElement;
        "sbb-logo": HTMLSbbLogoElement;
        "sbb-overlay": HTMLSbbOverlayElement;
        "sbb-pearl-chain": HTMLSbbPearlChainElement;
        "sbb-section": HTMLSbbSectionElement;
        "sbb-signet": HTMLSbbSignetElement;
        "sbb-slot-component": HTMLSbbSlotComponentElement;
        "sbb-stack": HTMLSbbStackElement;
        "sbb-tab-amount": HTMLSbbTabAmountElement;
        "sbb-tab-group": HTMLSbbTabGroupElement;
        "sbb-tab-title": HTMLSbbTabTitleElement;
        "sbb-teaser": HTMLSbbTeaserElement;
        "sbb-teaser-hero": HTMLSbbTeaserHeroElement;
        "sbb-timetable": HTMLSbbTimetableElement;
        "sbb-timetable-barrier-free": HTMLSbbTimetableBarrierFreeElement;
        "sbb-timetable-button": HTMLSbbTimetableButtonElement;
        "sbb-timetable-cus-him": HTMLSbbTimetableCusHimElement;
        "sbb-timetable-duration": HTMLSbbTimetableDurationElement;
        "sbb-timetable-occupancy": HTMLSbbTimetableOccupancyElement;
        "sbb-timetable-park-and-rail": HTMLSbbTimetableParkAndRailElement;
        "sbb-timetable-platform": HTMLSbbTimetablePlatformElement;
        "sbb-timetable-row": HTMLSbbTimetableRowElement;
        "sbb-timetable-row-button": HTMLSbbTimetableRowButtonElement;
        "sbb-timetable-row-column-headers": HTMLSbbTimetableRowColumnHeadersElement;
        "sbb-timetable-row-day-change": HTMLSbbTimetableRowDayChangeElement;
        "sbb-timetable-row-header": HTMLSbbTimetableRowHeaderElement;
        "sbb-timetable-transportation-details": HTMLSbbTimetableTransportationDetailsElement;
        "sbb-timetable-transportation-number": HTMLSbbTimetableTransportationNumberElement;
        "sbb-timetable-transportation-time": HTMLSbbTimetableTransportationTimeElement;
        "sbb-timetable-transportation-walk": HTMLSbbTimetableTransportationWalkElement;
        "sbb-timetable-travel-hints": HTMLSbbTimetableTravelHintsElement;
        "sbb-title": HTMLSbbTitleElement;
        "sbb-toggle-check": HTMLSbbToggleCheckElement;
    }
}
declare namespace LocalJSX {
    interface SbbAccordion {
        /**
          * Use the aria-labelledby to reference to an id of a title outside of the accordion. That way we can improve the context for the screenreader users. When the first button in the accordion receives focus, the referenced title is also spoken out by the screenreader.
         */
        "ariaLabelledby"?: string;
        /**
          * Set this if you want to use the accordion on a non-white background.
         */
        "nonWhiteBackground"?: boolean;
        /**
          * Set this if you want the accordion to always have open only one item.
         */
        "onlyOneOpen"?: boolean;
    }
    interface SbbAccordionItem {
        /**
          * If set, an accordion can not be toggled
         */
        "disabled"?: boolean;
        /**
          * Id which is sent in the event after opening/closing accordion
         */
        "eventId"?: string;
        /**
          * Text to show as title for the accordion.
         */
        "heading": string;
        /**
          * Heading level.
         */
        "headingLevel"?: InterfaceAccordionItemAttributes['level'];
        /**
          * Set to true to open the accordion item. Set to false to close it.
         */
        "open"?: boolean;
    }
    interface SbbActionGroup {
        "align"?: InterfaceSbbActionGroupAttributes['align'];
        "horizontalFrom"?: InterfaceSbbActionGroupAttributes['horizontalFrom'];
        "orientation"?: InterfaceSbbActionGroupAttributes['orientation'];
    }
    interface SbbAlert {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby"?: string | undefined;
        /**
          * This will be forwarded as aria-label to the relevant nested element.
         */
        "accessibilityLabel"?: string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby"?: string | undefined;
        /**
          * The href value you want to link to.
         */
        "href"?: string | undefined;
        /**
          * Name of the icon which will be forward to the nested `sbb-icon`. Choose the icons from https://lyne.sbb.ch/tokens/icons/. Styling is optimized for icons of type HIM-CUS.
         */
        "iconName"?: string;
        /**
          * Whether the fade in animation should be disabled.
         */
        "inanimate"?: boolean;
        /**
          * With this way of handling the id we deviate from the recommended way that the host id is set with assignId(). This exception was made because the id must be used with the close button and therefore a reference must exist.
         */
        "internalId"?: string;
        /**
          * Content of the link
         */
        "linkContent"?: string;
        /**
          * Emits when the fade in animation ends and the button is displayed.
         */
        "onSbb-alert_did-present"?: (event: SbbAlertCustomEvent<void>) => void;
        /**
          * Emits when dismissal of an alert was requested.
         */
        "onSbb-alert_dismissal-requested"?: (event: SbbAlertCustomEvent<void>) => void;
        /**
          * Emits when the fade in animation starts.
         */
        "onSbb-alert_will-present"?: (event: SbbAlertCustomEvent<void>) => void;
        /**
          * Whether the alert is readonly. In readonly mode, there is no dismiss button offered to the user.
         */
        "readonly"?: boolean;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string | undefined;
        /**
          * You can choose between `m` or `l` size.
         */
        "size"?: InterfaceAlertAttributes['size'];
        /**
          * Where to display the linked URL.
         */
        "target"?: LinkTargetType | string | undefined;
        /**
          * Content of title.
         */
        "titleContent"?: string;
        /**
          * Level of title, will be rendered as heading tag (e.g. h3). Defaults to level 3.
         */
        "titleLevel"?: InterfaceTitleAttributes['level'];
    }
    interface SbbAlertGroup {
        /**
          * Title for this alert group which is only visible for screen reader users.
         */
        "accessibilityTitle"?: string;
        /**
          * Level of the accessibility title, will be rendered as heading tag (e.g. h2). Defaults to level 2.
         */
        "accessibilityTitleLevel"?: InterfaceTitleAttributes['level'];
        /**
          * Emits when an alert was removed from DOM.
         */
        "onSbb-alert-group_did-dismiss-alert"?: (event: SbbAlertGroupCustomEvent<HTMLSbbAlertElement>) => void;
        /**
          * Emits when `sbb-alert-group` becomes empty.
         */
        "onSbb-alert-group_empty"?: (event: SbbAlertGroupCustomEvent<void>) => void;
        /**
          * The role attribute defines how to announce alerts to the user.  'status': sets aria-live to polite and aria-atomic to true. 'alert': sets aria-live to assertive and aria-atomic to true.
         */
        "role"?: InterfaceSbbAlertGroupAttributes['role'];
    }
    interface SbbAutocomplete {
        /**
          * Autocomplete id. If you use multiple instances on a page, you should set individual id's to each of them.
         */
        "autocompleteId"?: string;
        /**
          * Id which is sent as the id in the eventDetail payload when a value is selected
         */
        "eventId"?: string;
        /**
          * Define if borderless variant of autocomplete input should be used. See documentation of sbb-text-input for details.
         */
        "inputBorderless"?: boolean;
        /**
          * Debounce timeout to use for the input. See documentation of sbb-text-input for details.
         */
        "inputDebounceTimeout"?: number;
        /**
          * Label attribute for the input element. See sbb-text-input for details.
         */
        "inputLabel": string;
        /**
          * Determine if the input label should be visible. See sbb-text-input for details.
         */
        "inputLabelVisible"?: boolean;
        /**
          * Name attribute for the input element. See sbb-text-input for details.
         */
        "inputName": string;
        /**
          * Placeholder attribute for the input element. See sbb-text-input for details.
         */
        "inputPlaceholder"?: string;
        /**
          * Items to show in the autocomplete interface. You should pass a stringified array of objects, containing the `text` key for each object with an appropriate value.
         */
        "items"?: string;
        /**
          * Define how many chars a user must type into the input field for the autocomplete list to show up.
         */
        "minChars"?: number;
        /**
          * The value to use as default value for the input. The input value or the selected autocomplete value is reflected to this attribute.
         */
        "value"?: string;
    }
    interface SbbAutocompleteItem {
        /**
          * The aria-posinset attribute for the list element
         */
        "ariaPosinset"?: number;
        /**
          * The aira-setsize attribute for the list element
         */
        "ariaSetsize"?: number;
        /**
          * The text to highlight within the string property
         */
        "highlight"?: string;
        /**
          * Mark the item as selected, which will change it's appearance and the according aria attributes.
         */
        "selected"?: boolean;
        /**
          * Text to show as content of the autocomplete item
         */
        "text": string;
    }
    interface SbbButton {
        /**
          * The aria-controls property identifies the element (or elements) whose contents or presence are controlled by the element on which this attribute is set. The value is forwarded to the native button element.
         */
        "ariaControls"?: InterfaceButtonAttributes['ariaControls'];
        /**
          * If you use the button to trigger another widget which itself is covering the page, you must provide an according attribute for aria-haspopup.
         */
        "ariaHaspopup"?: InterfaceButtonAttributes['popup'];
        /**
          * Set to true to get a disabled button
         */
        "disabled"?: boolean;
        /**
          * Id which is sent in the click event payload
         */
        "eventId"?: string;
        /**
          * Define if icon should be shown or not
         */
        "icon"?: boolean;
        /**
          * If you use an icon without a label, you must provide an iconDescription
         */
        "iconDescription"?: string;
        /**
          * Label text to show on the button
         */
        "label"?: string;
        /**
          * The name attribute to use for the button
         */
        "name"?: string;
        /**
          * Emits whenever the native button click event triggers. TODO: Switch to a better event type during refactoring sbb-button.
         */
        "onSbb-button_click"?: (event: SbbButtonCustomEvent<any>) => void;
        /**
          * Size variant, either l or m.
         */
        "size"?: InterfaceButtonAttributes['size'];
        /**
          * The type attribute to use for the button
         */
        "type"?: InterfaceButtonAttributes['type'];
        /**
          * The value attribute to use for the button
         */
        "value"?: string;
        /**
          * Variant of the button, like primary, secondary etc.
         */
        "variant"?: InterfaceButtonAttributes['variant'];
        /**
          * Set this property to true if you want only a visual represenation of a button, but no interaction (a div instead of a button will be rendered).
         */
        "visualButtonOnly"?: boolean;
    }
    interface SbbCard {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby"?: string | undefined;
        /**
          * This will be forwarded as aria-label to the relevant nested element.
         */
        "accessibilityLabel"?: string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby"?: string | undefined;
        /**
          * Used to set the component's active state.
         */
        "active"?: boolean;
        /**
          * Whether the browser will show the download dialog on click.
         */
        "download"?: boolean | undefined;
        /**
          * The <form> element to associate the button with.
         */
        "form"?: string | undefined;
        /**
          * The href value you want to link to.
         */
        "href"?: string | undefined;
        /**
          * Id used to identify the inner element.
         */
        "idValue"?: string;
        /**
          * The name of the button.
         */
        "name"?: string | undefined;
        /**
          * Option for set the component background color.
         */
        "negative"?: boolean;
        /**
          * Emits whenever the native button click event triggers.
         */
        "onSbb-card-button_click"?: (event: SbbCardCustomEvent<any>) => void;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string | undefined;
        /**
          * Size variant, either xs, s, m, l, xl or xxl.
         */
        "size"?: InterfaceSbbCardAttributes['size'];
        /**
          * Where to display the linked URL.
         */
        "target"?: LinkTargetType | string | undefined;
        /**
          * Default behaviour of the button.
         */
        "type"?: ButtonType | undefined;
        /**
          * The value associated with button `name` when it's submitted with the form data.
         */
        "value"?: string | undefined;
    }
    interface SbbCardBadge {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby"?: string | undefined;
        /**
          * Accessibility label text. This text gets exposed to screen reader users. The text should reflect all the information which gets passed into the component (as text or within the slot) so which is visible in the card badge, either through text or iconography.  Example text: Sales ticket price starts at CHF 37.50
         */
        "accessibilityLabel"?: string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby"?: string | undefined;
        /**
          * Badge appearance
         */
        "appearance"?: InterfaceCardBadgeAttributes['appearance'];
        /**
          * Mark as discount
         */
        "isDiscount"?: boolean;
        /**
          * Price text
         */
        "price"?: string;
        /**
          * Badge size
         */
        "size"?: InterfaceCardBadgeAttributes['size'];
        /**
          * From/above price text
         */
        "text"?: string;
    }
    interface SbbCardProduct {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby"?: string | undefined;
        /**
          * The text which gets exposed to screen reader users. The text should reflect all the information which gets passed into the component's slots and which is visible in the card, either through text or iconography.  Example text: Connection from X to Y, via Z, on date X. Ticket price starts at X.
         */
        "accessibilityLabel"?: string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby"?: string | undefined;
        /**
          * CardProduct appearance
         */
        "appearance"?: InterfaceCardProductAttributes['appearance'];
        /**
          * If you use the button to trigger another widget which itself is covering the page, you must provide an according attribute for aria-haspopup.
         */
        "ariaHaspopup"?: InterfaceCardProductAttributes['popup'];
        /**
          * Id which is sent in the click event payload
         */
        "eventId"?: string;
        /**
          * The href value you want to link to
         */
        "hrefValue"?: string;
        /**
          * The ID value you want to reference
         */
        "idValue"?: string;
        /**
          * Defines if the card behaves like a HTML button. Needs to be set true if the card does not point to a URL.
         */
        "isButton"?: boolean;
        /**
          * Set to true to get a disabled button
         */
        "isDisabled"?: boolean;
        /**
          * CardProduct layout
         */
        "layout"?: InterfaceCardProductAttributes['layout'];
        /**
          * The name attribute to use for the button
         */
        "name"?: string;
        /**
          * The type attribute to use for the button
         */
        "type"?: InterfaceCardProductAttributes['type'];
        /**
          * The value attribute to use for the button
         */
        "value"?: string;
    }
    interface SbbClock {
        /**
          * initialTime accepts a string following a ${number}:${number}:${number} pattern. If left empty or the string 'now' is used we will set the current time the client has on its device.
         */
        "initialTime"?: Time;
        /**
          * If set to true, the clock will be paused.
         */
        "paused"?: boolean;
    }
    interface SbbDivider {
        /**
          * Appearance property for displaying the component in dark mode
         */
        "negative"?: boolean;
        /**
          * Orientation property with possible values 'horizontal' | 'vertical'. Defaults to horizontal.
         */
        "orientation"?: InterfaceSbbDividerAttributes['orientation'];
    }
    interface SbbFooter {
        /**
          * Footer title text, visually hidden,  necessary for screenreaders
         */
        "accessibilityTitle": string;
        /**
          * Footer appearance
         */
        "appearance"?: InterfaceFooterAttributes['appearance'];
    }
    interface SbbFormError {
    }
    interface SbbFormField {
        /**
          * Whether to display the form field without a border.
         */
        "borderless"?: boolean;
        /**
          * Whether to reserve space for an error message. `none` does not reserve any space. `reserve` does reserve one row for an error message.
         */
        "errorSpace"?: InterfaceSbbFormFieldAttributes['errorSpace'];
        /**
          * Label text for the input which is internally rendered as `<label>`.
         */
        "label"?: string;
        /**
          * Indicates whether the input is optional.
         */
        "optional"?: boolean;
        /**
          * Size variant, either l or m.
         */
        "size"?: InterfaceSbbFormFieldAttributes['size'];
    }
    interface SbbGrid {
        /**
          * Section appearance
         */
        "appearance"?: InterfaceGridAttributes['appearance'];
        /**
          * Grid variant
         */
        "variant"?: InterfaceGridAttributes['variant'];
    }
    interface SbbIcon {
        /**
          * The aria-hidden property is set to "true" by default, since an icon alone does not convey any useful information for a screen-reader user.
         */
        "ariaHidden"?: string;
        /**
          * Only set the aria-label if aria-hidden is set to "false".
         */
        "ariaLabel"?: string;
        /**
          * The provided name consisting of the namespace and the name of the icon. If the namespace is missing, the default namespace "sbb" will be used. E.g. `name` (will use "sbb" as namespace) or `namespace:name`.
         */
        "name"?: string;
        /**
          * When set to `false`, SVG content that is HTTP fetched will not be checked if the response SVG content has any `<script>` elements, or any attributes that start with `on`, such as `onclick`.
          * @default true
         */
        "sanitize"?: boolean;
    }
    interface SbbImage {
        /**
          * An alt text is not always necessary (e.g. in teaser cards when additional link text is provided). In this case we can leave the value of the alt attribute blank, but the attribute itself still needs to be present. That way we can signal assistive technology, that they can skip the image.
         */
        "alt"?: string;
        /**
          * Set an aspect ratio default is '16-9' (16/9) other values: 'free', '1-1', '1-2', '2-1', '2-3', '3-2', '3-4', '4-3', '4-5', '5-4', '9-16'
         */
        "aspectRatio"?: InterfaceImageAttributes['aspectRatio'];
        /**
          * border-radius: if set to false, there will be no border-radius on the image
         */
        "borderRadius"?: boolean;
        /**
          * A caption can provide additional context to the image (e.g. descriptions and the like). Links will automatically receive tabindex=-1 if hideFromScreenreader is set to true. That way they will no longer become focusable.
         */
        "caption"?: string;
        /**
          * If a copyright text is provided, we will add it to the caption and create a structured data json-ld block with the copyright information.
         */
        "copyright"?: string;
        /**
          * Copyright holder can either be an Organization or a Person
         */
        "copyrightHolder"?: InterfaceImageAttributes['copyrightHolder'];
        /**
          * Set this to true, if you want to pass a custom focal point for the image. See full documentation here: https://docs.imgix.com/apis/rendering/focalpoint-crop
         */
        "customFocalPoint"?: boolean;
        /**
          * If the lazy property is set to true, the module will automatically change the decoding to async, otherwise the decoding is set to auto which leaves the handling up to the browser. Read more about the decoding attribute here: https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decoding
         */
        "decoding"?: InterfaceImageAttributes['decoding'];
        /**
          * Set this to true, to receive visual guidance where the custom focal point is currently set.
         */
        "focalPointDebug"?: boolean;
        /**
          * Pass in a floating number between 0 (left) and 1 (right).
         */
        "focalPointX"?: number;
        /**
          * Pass in a floating number between 0 (top) and 1 (bottom).
         */
        "focalPointY"?: number;
        /**
          * Right now the module is heavily coupled with the image delivery service imgix and depends on the original files being stored inside of AEM. You can pass in any https://cdn.img.sbb.ch img src address you find on sbb.ch to play around with it. Just strip the url parameters and paste in the plain file address. If you want to know how to best work with this module with images coming from a different source, please contact the LYNE Core Team.
         */
        "imageSrc"?: string;
        /**
          * The importance attribute is fairly new attribute which should help the browser decide which resources it should prioritise during page load. We will set the attribute value based on the value, we receive in the loading attribute. 'eager', which we use for the largest image within the initial viewport, will set the attribute value to 'high'. 'lazy', which we use for images below the fold, will set the attribute value to 'low'.
         */
        "importance"?: InterfaceImageAttributes['importance'];
        /**
          * With the support of native image lazy loading, we can now decide whether we want to load the image immediately or only once it is close to the visible viewport. The value eager is best used for images within the initial viewport. We want to load these images as fast as possible to improve the Core Web Vitals values. lazy on the other hand works best for images which are further down the page or invisible during the loading of the initial viewport.
         */
        "loading"?: InterfaceImageAttributes['loading'];
        /**
          * If set to true, we show a blurred version of the image as placeholder before the actual image shows up. This will help to improve the perceived loading performance. Read more about the idea of lqip here: https://medium.com/@imgix/lqip-your-images-for-fast-loading-2523d9ee4a62
         */
        "lqip"?: boolean;
        /**
          * With performance.mark you can log a timestamp associated with the name you define in performanceMark when a certain event is happening. In our case we will log the performance.mark into the PerformanceEntry API once the image is fully loaded. Performance monitoring tools like SpeedCurve or Lighthouse are then able to grab these entries from the PerformanceEntry API and give us additional information and insights about our page loading behaviour. We are then also able to monitor these values over a long period to see if our performance increases or decreases over time. Best to use lowercase strings here, separate words with underscores or dashes.
         */
        "performanceMark"?: string;
        /**
          * With the pictureSizesConfig object, you can pass in information into image about what kind of source elements should get rendered. mediaQueries accepts multiple Media Query entries which can get combined by defining a conditionOperator. Type is: stringified InterfaceImageAttributesSizesConfig-Object An example could look like this: {    "breakpoints": [      {        "image": {          "height": "675",          "width": "1200"        },        "mediaQueries": [          {            "conditionFeature": "min-width",            "conditionFeatureValue": {              "lyneDesignToken": true,              "value": "breakpoint-large-min"            },            "conditionOperator": false          }        ]      },      {        "image": {          "height": "549",          "width": "976"        },        "mediaQueries": [          {            "conditionFeature": "min-width",            "conditionFeatureValue": {              "lyneDesignToken": true,              "value": "breakpoint-small-min"            },            "conditionOperator": false          }        ]      },      {        "image": {          "height": "180",          "width": "320"        },        "mediaQueries": [          {            "conditionFeature": "max-width",            "conditionFeatureValue": {              "lyneDesignToken": true,              "value": "breakpoint-micro-max"            },            "conditionOperator": "and"          },          {            "conditionFeature": "orientation",            "conditionFeatureValue": {              "lyneDesignToken": false,              "value": "landscape"            },            "conditionOperator": false          }        ]      }    ]  }
         */
        "pictureSizesConfig"?: string;
    }
    interface SbbJourneyHeader {
        /**
          * Journey header appearance
         */
        "appearance"?: InterfaceJourneyHeaderAttributes['appearance'];
        /**
          * Destination location for the journey header
         */
        "destination": string;
        /**
          * Is the journey a round trip. If so it gets indicated through a roundtrip icon
         */
        "isRoundTrip"?: boolean;
        /**
          * A11y Tip: Sometimes we need to set an id, especially if we want to associate a relationship with another element through the use of aria-labelledby or aria-describedby or just offer an anchor target
         */
        "journeyHeaderId"?: '';
        /**
          * Journey header markup: Depends on the context where the journey will be used but it is important to pick the correct markup element to match to correct semantics
         */
        "markup"?: InterfaceJourneyHeaderAttributes['markup'];
        /**
          * Origin location for the journey header
         */
        "origin": string;
        /**
          * Journey header size
         */
        "size"?: InterfaceJourneyHeaderAttributes['size'];
    }
    interface SbbLink {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby"?: string | undefined;
        /**
          * This will be forwarded as aria-label to the relevant nested element.
         */
        "accessibilityLabel"?: string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby"?: string | undefined;
        /**
          * Disabled attribute if link is used as button (optional)
         */
        "disabled"?: boolean;
        /**
          * If set to true, the browser will show the download dialog on click (optional).
         */
        "download"?: boolean;
        /**
          * Id which is sent in the click event payload
         */
        "eventId"?: string;
        /**
          * Form attribute if link is used as button (optional)
         */
        "form"?: string;
        /**
          * The href value you want to link to (optional, if its not present link becomes a button)
         */
        "href"?: string | undefined;
        /**
          * The icon name we want to use, choose from the small icon variants from the ui-icons category from here https://lyne.sbb.ch/tokens/icons/ (optional). Inline variant doesn't support icons.
         */
        "iconName"?: string;
        /**
          * Moves the icon to the end of the component if set to true (optional).
         */
        "iconPlacement"?: InterfaceLinkAttributes['iconPlacement'];
        /**
          * Pass in an id, if you need to identify the link element (optional).
         */
        "idValue"?: string;
        /**
          * Name attribute if link is used as button (optional)
         */
        "name"?: string | undefined;
        /**
          * Negative coloring variant flag.
         */
        "negative"?: boolean;
        /**
          * Emits whenever the native button click event triggers. TODO: similar to the one in sbb-button. To be fixed together.
         */
        "onSbb-link-button_click"?: (event: SbbLinkCustomEvent<any>) => void;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string | undefined;
        /**
          * Where to display the linked URL.
         */
        "target"?: LinkTargetType | string | undefined;
        /**
          * Text size, the link should get in the non-button variation. With inline variant, the text size adapts to where it is used.
         */
        "textSize"?: InterfaceLinkAttributes['textSize'];
        /**
          * Type attribute if link is used as button (optional)
         */
        "type"?: InterfaceLinkAttributes['buttonType'] | undefined;
        /**
          * The value associated with button `name` when it's submitted with the form data.
         */
        "value"?: string;
        /**
          * Applies link inline styles (underline, inherit coloring/font-size etc).
         */
        "variant"?: InterfaceLinkAttributes['variant'];
    }
    interface SbbLinkButton {
        /**
          * If set to true, the browser will show the download dialog on click.
         */
        "download"?: boolean;
        /**
          * The href value you want to link to
         */
        "hrefValue": string;
        /**
          * The icon name we want to use, choose from the small icon variants from the ui-icons category from here https://lyne.sbb.ch/tokens/icons/
         */
        "icon"?: string;
        /**
          * Decide whether the icon should get flipped horizontally if the document writing mode is changed from ltr to rtl or vice versa.
         */
        "iconFlip"?: boolean;
        /**
          * The icon can either be place before or after the text
         */
        "iconPlacement"?: InterfaceLinkButtonAttributes['iconPlacement'];
        /**
          * Pass in an id, if you need to identify the link element.
         */
        "idValue"?: string;
        /**
          * The link text we want to visually show
         */
        "text": string;
        /**
          * Choose the link button style variant
         */
        "variant"?: InterfaceLinkButtonAttributes['variant'];
    }
    interface SbbLinkList {
        /**
          * Selected breakpoint from which the list is rendered horizontally.
         */
        "horizontalFrom"?: InterfaceLinkListAttributes['horizontalFromBreakpoint'];
        /**
          * Negative coloring variant flag.
         */
        "negative"?: boolean;
        /**
          * The orientation in which the list will be shown vertical or horizontal.
         */
        "orientation"?: InterfaceLinkListAttributes['orientation'];
        /**
          * The title text we want to show before the list.
         */
        "titleContent"?: string;
        /**
          * This id will be forwarded to the relevant inner element.
         */
        "titleId"?: string;
        /**
          * The semantic level of the title, e.g. 2 = h2.
         */
        "titleLevel"?: InterfaceTitleAttributes1['level'];
    }
    interface SbbLogo {
        /**
          * The Logo needs to have a certain protective room around it
         */
        "protectiveRoom"?: InterfaceLogoAttributes['protectiveRoom'];
        /**
          * According to the Corporate Design Guidelines the logo can be used in these variants
         */
        "variant"?: InterfaceLogoAttributes['variant'];
    }
    interface SbbOverlay {
        "onDidDismiss"?: (event: SbbOverlayCustomEvent<InterfaceOverlayEventDetail>) => void;
        "onDidPresent"?: (event: SbbOverlayCustomEvent<void>) => void;
        "onWillDismiss"?: (event: SbbOverlayCustomEvent<InterfaceOverlayEventDetail>) => void;
        "onWillPresent"?: (event: SbbOverlayCustomEvent<void>) => void;
        "overlayIndex"?: number;
    }
    interface SbbPearlChain {
        /**
          * Per default, the current location has a pulsating animation. You can disable the animation with this property.
         */
        "disableAnimation"?: boolean;
        /**
          * Stringified JSON to define the legs of the pearl-chain. Format: `{"legs": [{"cancellation": true, "duration": 25}, ...]}` `duration`: number between 0 and 100. Duration of the leg is relative to the total travel time. Example: departure 16:30, change at 16:40, arrival at 17:00. So the change should have a duration of 33.33%. `cancellation`: if set, the leg will be marked as canceled.
         */
        "legs": string;
        /**
          * Define, if the pearl-chain represents a connection in the past, in the future or if it is a currently running connection. If it is currently running, provide a number between 0 and 100, which will represent the current location on the pearl-chain.
         */
        "status"?: InterfacePearlChainAttributes['status'];
    }
    interface SbbSection {
        /**
          * Section appearance
         */
        "appearance"?: InterfaceSectionAttributes['appearance'];
        /**
          * Section width
         */
        "width"?: InterfaceSectionAttributes['width'];
    }
    interface SbbSignet {
        /**
          * The Signet needs to have a certain protective room around it
         */
        "protectiveRoom"?: InterfaceSignetAttributes['protectiveRoom'];
        /**
          * According to the Corporate Design Guidelines the signet can be used in these variants
         */
        "variant"?: InterfaceSignetAttributes['variant'];
    }
    interface SbbSlotComponent {
    }
    interface SbbStack {
        /**
          * Stack appearance
         */
        "appearance"?: InterfaceStackAttributes['appearance'];
        /**
          * Collapse horizontal stack into vertical layout below a certain breakpoint. This has only an effect for horizontal appearances.
         */
        "collapseHorizontalBelow"?: InterfaceStackAttributes['collapseHorizontalBelow'];
        /**
          * Stack gap horizontal, defines the space between each stack items in the vertical direction. The spacing can be fixed or responsive (which then depends on the breakpoint). The `x` in the fixed spacing scale is a representation of the base spacing unit. E.g. `3 * base spacing unit`
         */
        "gapHorizontal"?: InterfaceStackAttributes['spacing'];
        /**
          * Stack gap vertical, defines the space between each stack items in the horizontal direction. The spacing can be fixed or responsive (which then depends on the breakpoint). The `x` in the fixed spacing scale is a representation of the base spacing unit. E.g. `3 * base spacing unit`
         */
        "gapVertical"?: InterfaceStackAttributes['spacing'];
        /**
          * Render stack as placeholder
         */
        "isPlaceholder"?: boolean;
        /**
          * Render horizontal stack as non-wrapping stack
         */
        "noWrap"?: boolean;
        /**
          * Space before the stack
         */
        "spaceLeading"?: InterfaceStackAttributes['spacing'];
        /**
          * Space before the stack
         */
        "spaceTrailing"?: InterfaceStackAttributes['spacing'];
        /**
          * Stack height, reflects CSS property `height` and accepts all appropriate/valid CSS height values
         */
        "stackHeight"?: string;
        /**
          * Stack width, reflects CSS property `width` and accepts all appropriate/valid CSS width values
         */
        "stackWidth"?: string;
        /**
          * Stack tag / HTML representation of the stack. If the stack represents a list of items change the HTML representation to `ul` or `ol` tag. In this case the only allowed stack items are `li` elements.
         */
        "tag"?: InterfaceStackAttributes['tag'];
    }
    interface SbbTabAmount {
    }
    interface SbbTabGroup {
        /**
          * Sets the initial tab. If it matches a disabled tab or exceeds the length of the tab group, the first enabled tab will be selected.
         */
        "initialSelectedIndex"?: number;
        /**
          * Emits an event on selected tab change
         */
        "onSbb-tab-group_did-change"?: (event: SbbTabGroupCustomEvent<void>) => void;
    }
    interface SbbTabTitle {
        /**
          * Active tab state
         */
        "active"?: boolean;
        /**
          * Disabled tab state
         */
        "disabled"?: boolean;
        /**
          * The level will correspond to the heading tag generated in the title. Use this property to generate the appropriate header tag, taking SEO into consideration.
         */
        "level"?: InterfaceTabTitleAttributes['level'];
    }
    interface SbbTeaser {
        /**
          * This will be forwarded as aria-describedby to the relevant nested element.
         */
        "accessibilityDescribedby"?: string | undefined;
        /**
          * The text which gets exposed to screen reader users. The text should reflect all the information  Example text: Connection from X to Y, via Z, on date X. Ticket price starts at X.
         */
        "accessibilityLabel": string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the relevant nested element.
         */
        "accessibilityLabelledby"?: string | undefined;
        /**
          * The href value you want to link to
         */
        "href": string;
        /**
          * Teaser variant - when this is true the text-content will be under the image otherwise it will be displayed next to the image.
         */
        "isStacked"?: boolean;
        /**
          * Heading level of the sbb-title element (e.g. h1-h6)
         */
        "titleLevel"?: InterfaceTeaserAttributes['titleLevel'];
    }
    interface SbbTeaserHero {
        /**
          * This will be forwarded as aria-describedby to the anchor tag.
         */
        "accessibilityDescribedby"?: string | undefined;
        /**
          * This will be forwarded as aria-label to anchor tag.
         */
        "accessibilityLabel"?: string | undefined;
        /**
          * This will be forwarded as aria-labelledby to the anchor tag.
         */
        "accessibilityLabelledby"?: string | undefined;
        /**
          * The href value you want to link to.
         */
        "href"?: string | undefined;
        /**
          * Pass in an id, if you need to identify the inner link element.
         */
        "idValue"?: string;
        /**
          * Image alt text will be passed to `sbb-image`.
         */
        "imageAlt"?: string;
        /**
          * Image src will be passed to `sbb-image`.
         */
        "imageSrc"?: string;
        /**
          * Panel link text.
         */
        "linkContent"?: string;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string | undefined;
        /**
          * Where to display the linked URL.
         */
        "target"?: LinkTargetType | string | undefined;
    }
    interface SbbTimetable {
    }
    interface SbbTimetableBarrierFree {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableButton {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableButtonAttributes['appearance'];
        /**
          * If you use the button to trigger another widget which itself is covering the page, you must provide an according attribute for aria-haspopup.
         */
        "ariaHaspopup"?: InterfaceTimetableButtonAttributes['popup'];
        /**
          * If appearance is set to 'cus-him' or 'walk', we need to provide a config to popultate the nested web component.
         */
        "config"?: string;
        /**
          * Set to true to get a disabled button
         */
        "disabled"?: boolean;
        /**
          * Id which is sent in the click event payload
         */
        "eventId"?: string;
        /**
          * Set to true to initially show the state, which would get set by pressing the button.
         */
        "expanded"?: boolean;
        /**
          * The name attribute to use for the button
         */
        "name"?: string;
    }
    interface SbbTimetableCusHim {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableCusHimAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableDuration {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableOccupancy {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableParkAndRail {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableParkAndRailAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetablePlatform {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetablePlatformAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableRow {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableRowButton {
        /**
          * Id which is sent in the event of clicking the button
         */
        "eventId"?: string;
        /**
          * Set to true to initially show the state, which would get set by pressing the button.
         */
        "expanded"?: boolean;
    }
    interface SbbTimetableRowColumnHeaders {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableRowDayChange {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableRowHeader {
        "config": string;
    }
    interface SbbTimetableTransportationDetails {
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableTransportationNumber {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableTransportationNumberAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableTransportationTime {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableTransportationTimeAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableTransportationWalk {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableTransportationWalkAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTimetableTravelHints {
        /**
          * Set the desired appearance of the component.
         */
        "appearance"?: InterfaceTimetableTravelHintsAttributes['appearance'];
        /**
          * Stringified JSON which defines most of the content of the component. Please check the individual stories to get an idea of the structure.
         */
        "config": string;
    }
    interface SbbTitle {
        /**
          * Title level
         */
        "level"?: InterfaceTitleAttributes['level'];
        /**
          * Choose negative variant
         */
        "negative"?: boolean;
        /**
          * A11y Tip: Sometimes we need to set an id, especially if we want to associate a relationship with another element through the use of aria-labelledby or aria-describedby or just offer an anchor target
         */
        "titleId"?: string;
        /**
          * Visual level for the title. Optional, if not set, the value of level will be used.
         */
        "visualLevel"?: InterfaceTitleAttributes['visualLevel'];
        /**
          * Sometimes we need a title in the markup to present a proper hierarchy to the screenreaders while we do not want to let that title appear visually. In this case we set visuallyHidden to true
         */
        "visuallyHidden"?: false;
    }
    interface SbbToggleCheck {
        /**
          * The aria-describedby prop for the hidden input.
         */
        "accessibilityDescribedby"?: string | undefined;
        /**
          * The aria-label prop for the hidden input.
         */
        "accessibilityLabel"?: string | undefined;
        /**
          * The aria-labelledby prop for the hidden input.
         */
        "accessibilityLabelledby"?: string | undefined;
        /**
          * Whether the toggle-check is checked.
         */
        "checked"?: boolean;
        /**
          * The disabled prop for the disabled state.
         */
        "disabled": boolean;
        /**
          * The svg name for the true state - default -> 'tick-small'
         */
        "icon"?: string;
        /**
          * Id of the internal input element - default id will be set automatically.
         */
        "inputId"?: string;
        /**
          * The label position relative to the toggle. Defaults to 'after'
         */
        "labelPosition"?: InterfaceToggleCheckAttributes['labelPosition'];
        /**
          * Name of the toggle-check.
         */
        "name"?: string;
        /**
          * Emits whenever the selection has changed.
         */
        "onSbbChange"?: (event: SbbToggleCheckCustomEvent<any>) => void;
        /**
          * The required prop for the required state.
         */
        "required"?: boolean;
        /**
          * Value of toggle-check.
         */
        "value"?: string;
    }
    interface IntrinsicElements {
        "sbb-accordion": SbbAccordion;
        "sbb-accordion-item": SbbAccordionItem;
        "sbb-action-group": SbbActionGroup;
        "sbb-alert": SbbAlert;
        "sbb-alert-group": SbbAlertGroup;
        "sbb-autocomplete": SbbAutocomplete;
        "sbb-autocomplete-item": SbbAutocompleteItem;
        "sbb-button": SbbButton;
        "sbb-card": SbbCard;
        "sbb-card-badge": SbbCardBadge;
        "sbb-card-product": SbbCardProduct;
        "sbb-clock": SbbClock;
        "sbb-divider": SbbDivider;
        "sbb-footer": SbbFooter;
        "sbb-form-error": SbbFormError;
        "sbb-form-field": SbbFormField;
        "sbb-grid": SbbGrid;
        "sbb-icon": SbbIcon;
        "sbb-image": SbbImage;
        "sbb-journey-header": SbbJourneyHeader;
        "sbb-link": SbbLink;
        "sbb-link-button": SbbLinkButton;
        "sbb-link-list": SbbLinkList;
        "sbb-logo": SbbLogo;
        "sbb-overlay": SbbOverlay;
        "sbb-pearl-chain": SbbPearlChain;
        "sbb-section": SbbSection;
        "sbb-signet": SbbSignet;
        "sbb-slot-component": SbbSlotComponent;
        "sbb-stack": SbbStack;
        "sbb-tab-amount": SbbTabAmount;
        "sbb-tab-group": SbbTabGroup;
        "sbb-tab-title": SbbTabTitle;
        "sbb-teaser": SbbTeaser;
        "sbb-teaser-hero": SbbTeaserHero;
        "sbb-timetable": SbbTimetable;
        "sbb-timetable-barrier-free": SbbTimetableBarrierFree;
        "sbb-timetable-button": SbbTimetableButton;
        "sbb-timetable-cus-him": SbbTimetableCusHim;
        "sbb-timetable-duration": SbbTimetableDuration;
        "sbb-timetable-occupancy": SbbTimetableOccupancy;
        "sbb-timetable-park-and-rail": SbbTimetableParkAndRail;
        "sbb-timetable-platform": SbbTimetablePlatform;
        "sbb-timetable-row": SbbTimetableRow;
        "sbb-timetable-row-button": SbbTimetableRowButton;
        "sbb-timetable-row-column-headers": SbbTimetableRowColumnHeaders;
        "sbb-timetable-row-day-change": SbbTimetableRowDayChange;
        "sbb-timetable-row-header": SbbTimetableRowHeader;
        "sbb-timetable-transportation-details": SbbTimetableTransportationDetails;
        "sbb-timetable-transportation-number": SbbTimetableTransportationNumber;
        "sbb-timetable-transportation-time": SbbTimetableTransportationTime;
        "sbb-timetable-transportation-walk": SbbTimetableTransportationWalk;
        "sbb-timetable-travel-hints": SbbTimetableTravelHints;
        "sbb-title": SbbTitle;
        "sbb-toggle-check": SbbToggleCheck;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "sbb-accordion": LocalJSX.SbbAccordion & JSXBase.HTMLAttributes<HTMLSbbAccordionElement>;
            "sbb-accordion-item": LocalJSX.SbbAccordionItem & JSXBase.HTMLAttributes<HTMLSbbAccordionItemElement>;
            "sbb-action-group": LocalJSX.SbbActionGroup & JSXBase.HTMLAttributes<HTMLSbbActionGroupElement>;
            "sbb-alert": LocalJSX.SbbAlert & JSXBase.HTMLAttributes<HTMLSbbAlertElement>;
            "sbb-alert-group": LocalJSX.SbbAlertGroup & JSXBase.HTMLAttributes<HTMLSbbAlertGroupElement>;
            "sbb-autocomplete": LocalJSX.SbbAutocomplete & JSXBase.HTMLAttributes<HTMLSbbAutocompleteElement>;
            "sbb-autocomplete-item": LocalJSX.SbbAutocompleteItem & JSXBase.HTMLAttributes<HTMLSbbAutocompleteItemElement>;
            "sbb-button": LocalJSX.SbbButton & JSXBase.HTMLAttributes<HTMLSbbButtonElement>;
            "sbb-card": LocalJSX.SbbCard & JSXBase.HTMLAttributes<HTMLSbbCardElement>;
            "sbb-card-badge": LocalJSX.SbbCardBadge & JSXBase.HTMLAttributes<HTMLSbbCardBadgeElement>;
            "sbb-card-product": LocalJSX.SbbCardProduct & JSXBase.HTMLAttributes<HTMLSbbCardProductElement>;
            "sbb-clock": LocalJSX.SbbClock & JSXBase.HTMLAttributes<HTMLSbbClockElement>;
            "sbb-divider": LocalJSX.SbbDivider & JSXBase.HTMLAttributes<HTMLSbbDividerElement>;
            "sbb-footer": LocalJSX.SbbFooter & JSXBase.HTMLAttributes<HTMLSbbFooterElement>;
            "sbb-form-error": LocalJSX.SbbFormError & JSXBase.HTMLAttributes<HTMLSbbFormErrorElement>;
            "sbb-form-field": LocalJSX.SbbFormField & JSXBase.HTMLAttributes<HTMLSbbFormFieldElement>;
            "sbb-grid": LocalJSX.SbbGrid & JSXBase.HTMLAttributes<HTMLSbbGridElement>;
            "sbb-icon": LocalJSX.SbbIcon & JSXBase.HTMLAttributes<HTMLSbbIconElement>;
            "sbb-image": LocalJSX.SbbImage & JSXBase.HTMLAttributes<HTMLSbbImageElement>;
            "sbb-journey-header": LocalJSX.SbbJourneyHeader & JSXBase.HTMLAttributes<HTMLSbbJourneyHeaderElement>;
            "sbb-link": LocalJSX.SbbLink & JSXBase.HTMLAttributes<HTMLSbbLinkElement>;
            "sbb-link-button": LocalJSX.SbbLinkButton & JSXBase.HTMLAttributes<HTMLSbbLinkButtonElement>;
            "sbb-link-list": LocalJSX.SbbLinkList & JSXBase.HTMLAttributes<HTMLSbbLinkListElement>;
            "sbb-logo": LocalJSX.SbbLogo & JSXBase.HTMLAttributes<HTMLSbbLogoElement>;
            "sbb-overlay": LocalJSX.SbbOverlay & JSXBase.HTMLAttributes<HTMLSbbOverlayElement>;
            "sbb-pearl-chain": LocalJSX.SbbPearlChain & JSXBase.HTMLAttributes<HTMLSbbPearlChainElement>;
            "sbb-section": LocalJSX.SbbSection & JSXBase.HTMLAttributes<HTMLSbbSectionElement>;
            "sbb-signet": LocalJSX.SbbSignet & JSXBase.HTMLAttributes<HTMLSbbSignetElement>;
            "sbb-slot-component": LocalJSX.SbbSlotComponent & JSXBase.HTMLAttributes<HTMLSbbSlotComponentElement>;
            "sbb-stack": LocalJSX.SbbStack & JSXBase.HTMLAttributes<HTMLSbbStackElement>;
            "sbb-tab-amount": LocalJSX.SbbTabAmount & JSXBase.HTMLAttributes<HTMLSbbTabAmountElement>;
            "sbb-tab-group": LocalJSX.SbbTabGroup & JSXBase.HTMLAttributes<HTMLSbbTabGroupElement>;
            "sbb-tab-title": LocalJSX.SbbTabTitle & JSXBase.HTMLAttributes<HTMLSbbTabTitleElement>;
            "sbb-teaser": LocalJSX.SbbTeaser & JSXBase.HTMLAttributes<HTMLSbbTeaserElement>;
            "sbb-teaser-hero": LocalJSX.SbbTeaserHero & JSXBase.HTMLAttributes<HTMLSbbTeaserHeroElement>;
            "sbb-timetable": LocalJSX.SbbTimetable & JSXBase.HTMLAttributes<HTMLSbbTimetableElement>;
            "sbb-timetable-barrier-free": LocalJSX.SbbTimetableBarrierFree & JSXBase.HTMLAttributes<HTMLSbbTimetableBarrierFreeElement>;
            "sbb-timetable-button": LocalJSX.SbbTimetableButton & JSXBase.HTMLAttributes<HTMLSbbTimetableButtonElement>;
            "sbb-timetable-cus-him": LocalJSX.SbbTimetableCusHim & JSXBase.HTMLAttributes<HTMLSbbTimetableCusHimElement>;
            "sbb-timetable-duration": LocalJSX.SbbTimetableDuration & JSXBase.HTMLAttributes<HTMLSbbTimetableDurationElement>;
            "sbb-timetable-occupancy": LocalJSX.SbbTimetableOccupancy & JSXBase.HTMLAttributes<HTMLSbbTimetableOccupancyElement>;
            "sbb-timetable-park-and-rail": LocalJSX.SbbTimetableParkAndRail & JSXBase.HTMLAttributes<HTMLSbbTimetableParkAndRailElement>;
            "sbb-timetable-platform": LocalJSX.SbbTimetablePlatform & JSXBase.HTMLAttributes<HTMLSbbTimetablePlatformElement>;
            "sbb-timetable-row": LocalJSX.SbbTimetableRow & JSXBase.HTMLAttributes<HTMLSbbTimetableRowElement>;
            "sbb-timetable-row-button": LocalJSX.SbbTimetableRowButton & JSXBase.HTMLAttributes<HTMLSbbTimetableRowButtonElement>;
            "sbb-timetable-row-column-headers": LocalJSX.SbbTimetableRowColumnHeaders & JSXBase.HTMLAttributes<HTMLSbbTimetableRowColumnHeadersElement>;
            "sbb-timetable-row-day-change": LocalJSX.SbbTimetableRowDayChange & JSXBase.HTMLAttributes<HTMLSbbTimetableRowDayChangeElement>;
            "sbb-timetable-row-header": LocalJSX.SbbTimetableRowHeader & JSXBase.HTMLAttributes<HTMLSbbTimetableRowHeaderElement>;
            "sbb-timetable-transportation-details": LocalJSX.SbbTimetableTransportationDetails & JSXBase.HTMLAttributes<HTMLSbbTimetableTransportationDetailsElement>;
            "sbb-timetable-transportation-number": LocalJSX.SbbTimetableTransportationNumber & JSXBase.HTMLAttributes<HTMLSbbTimetableTransportationNumberElement>;
            "sbb-timetable-transportation-time": LocalJSX.SbbTimetableTransportationTime & JSXBase.HTMLAttributes<HTMLSbbTimetableTransportationTimeElement>;
            "sbb-timetable-transportation-walk": LocalJSX.SbbTimetableTransportationWalk & JSXBase.HTMLAttributes<HTMLSbbTimetableTransportationWalkElement>;
            "sbb-timetable-travel-hints": LocalJSX.SbbTimetableTravelHints & JSXBase.HTMLAttributes<HTMLSbbTimetableTravelHintsElement>;
            "sbb-title": LocalJSX.SbbTitle & JSXBase.HTMLAttributes<HTMLSbbTitleElement>;
            "sbb-toggle-check": LocalJSX.SbbToggleCheck & JSXBase.HTMLAttributes<HTMLSbbToggleCheckElement>;
        }
    }
}
