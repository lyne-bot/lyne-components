@use '../../core/styles' as sbb;

// Box-sizing rules contained in typography are not traversing Shadow DOM boundaries. We need to include box-sizing mixin in every component.
@include sbb.box-sizing;

:host {
  display: block;

  --sbb-container-image-position: end;
}

:host([color='white']) {
  --sbb-container-background-color: var(--sbb-color-white);
}

:host([color='milk']) {
  --sbb-container-background-color: var(--sbb-color-milk);
}

:host([data-slot-names~='image']) {
  --sbb-container-background-color: transparent;
}

:host(:not([expanded])[background-expanded]) {
  background-color: var(--sbb-container-background-color);
}

.sbb-container {
  background-color: var(--sbb-container-background-color);

  @include sbb.ignore-children-margin;

  // In order to support nested sbb-containers (e.g. if used in an overlay), we need to explicitly set background color to transparent.
  // We cannot use the --sbb-container-background-color variable because using it would
  // destroy sbb-sticky-bar behavior when the container and the sticky bar have transparent color.
  :host([color='transparent']) & {
    background-color: transparent;
  }

  :host(:not([expanded])) & {
    @include sbb.page-spacing;
  }

  :host([expanded]) & {
    @include sbb.page-spacing-expanded;
  }

  :host([data-slot-names~='image']) & {
    position: relative;
  }
}

.sbb-container__content {
  position: relative;
}

::slotted([slot='image']) {
  --sbb-image-border-radius: 0;
  --sbb-image-object-position: var(--sbb-container-image-position);

  position: absolute;
  inset: 0;

  :host(:not([expanded])) & {
    @include sbb.mq($from: ultra) {
      --sbb-image-border-radius: var(--sbb-border-radius-4x);

      border-radius: var(--sbb-border-radius-4x);
    }
  }
}

::slotted(img[slot='image']) {
  object-fit: cover;
  object-position: var(--sbb-container-image-position);
  height: 100%;
  width: 100%;
}
