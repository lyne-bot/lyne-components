import {
  existsSync,
  mkdirSync,
  readFileSync,
  readdirSync,
  rmSync,
  statSync,
  unlinkSync,
  writeFileSync,
} from 'fs';

import type { CustomElementDeclaration, Package } from 'custom-elements-manifest/schema';
import { ConfigEnv, PluginOption, UserConfig, defineConfig, mergeConfig } from 'vite';
import dts from 'vite-plugin-dts';

import rootConfig, { globIndexMap, packageJsonTemplate, root } from '../../vite.config';

const packageRoot = new URL('.', import.meta.url);
const outDir = new URL('./dist/react/', root);

const isProdBuild = ({ command, mode }: ConfigEnv): boolean =>
  command === 'build' && mode !== 'development';

export default defineConfig((config) =>
  mergeConfig(rootConfig, <UserConfig>{
    root: packageRoot.pathname,
    plugins: [
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      generateReactWrappers(),
      ...(isProdBuild(config)
        ? [
            dts({
              entryRoot: '.',
              include: `**/*.ts`,
              exclude: ['**/*.{stories,spec,e2e}.{ts,tsx}', 'vite.config.ts'],
            }),
            packageJsonTemplate(),
          ]
        : []),
    ],
    build: {
      lib: {
        formats: ['es'],
      },
      minify: false,
      outDir: outDir.pathname,
      emptyOutDir: true,
      rollupOptions: {
        external: [/^@sbb-esta\/lyne-components\/?/, /^react/],
      },
    },
  }),
);

function generateReactWrappers(): PluginOption {
  const manifestPath = new URL('./dist/components/custom-elements.json', root);
  let manifest: Package;
  try {
    manifest = JSON.parse(readFileSync(manifestPath, 'utf8'));
  } catch (e) {
    console.error(
      `Failed to read manifest at ${manifestPath}. Please run 'yarn build:components' or 'yarn docs:manifest' first!`,
    );
    process.exit(1);
  }

  const generatedPaths: URL[] = [];
  function createDir(dir: URL): void {
    if (!existsSync(dir)) {
      createDir(new URL('..', dir));
      generatedPaths.push(dir);
      mkdirSync(dir);
    }
  }
  return {
    name: 'generate-react-wrappers',
    config(config) {
      for (const module of manifest.modules.filter((m) => m.kind === 'javascript-module')) {
        for (const declaration of module.declarations?.filter(
          (d): d is CustomElementDeclaration => 'customElement' in d && d.customElement,
        ) ?? []) {
          const targetPath = new URL(`./${module.path}/index.ts`, packageRoot);
          const targetDir = new URL('.', targetPath);
          createDir(targetDir);

          const reactTemplate = `/* autogenerated */
import { createComponent } from '@lit/react';
import { ${declaration.name} as ${declaration.name}Element } from '@sbb-esta/lyne-components/${
            module.path
          }';
import react from 'react';

// eslint-disable-next-line @typescript-eslint/naming-convention
export const ${declaration.name} = createComponent({
  tagName: '${declaration.tagName}',
  elementClass: ${declaration.name}Element,
  react,${
    declaration.events
      ? `
  events: {${declaration.events!.map((e) => `\n    'on${e.name}': '${e.name}',`).join('')}
  },
`
      : ''
  }
});
`;

          generatedPaths.push(targetPath);
          writeFileSync(targetPath, reactTemplate, 'utf8');
        }
      }

      for (const dirent of readdirSync(packageRoot, { withFileTypes: true }).filter((d) =>
        d.isDirectory(),
      )) {
        const dir = new URL(`./${dirent.name}/`, packageRoot);
        const dirIndex = new URL('./index.ts', dir);
        if (!existsSync(dirIndex)) {
          generatedPaths.push(dirIndex);
          const dirInfo = readdirSync(dir, { withFileTypes: true })
            .filter((d) => d.isDirectory())
            .map((d) => `export * from './${d.name}';\n`)
            .join('');
          writeFileSync(new URL('./index.ts', dir), dirInfo, 'utf8');
        }
      }

      config.build.lib = {
        ...(config.build.lib ? config.build.lib : {}),
        entry: globIndexMap(packageRoot),
      };
    },
    closeBundle() {
      for (const path of generatedPaths.sort((a, b) => b.pathname.length - a.pathname.length)) {
        try {
          if (statSync(path).isDirectory()) {
            rmSync(path, { recursive: true, force: true });
          } else {
            unlinkSync(path);
          }
        } catch {
          /* empty */
        }
      }
    },
  };
}
